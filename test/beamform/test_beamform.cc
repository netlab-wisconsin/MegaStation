#include <gtest/gtest.h>

#include <fstream>

#include "beamform/beamform.h"
#include "complex.h"
#include "matrix/matrix.h"

class BeamformTest : public testing::Test {
 protected:
  std::shared_ptr<mega::Complex> csi_in;
  std::shared_ptr<mega::Complex> csi_out;
  std::shared_ptr<mega::Complex> precoder;
  size_t sz_bytes;

  uint32_t ue;
  uint32_t bs;

  BeamformTest() : ue(4), bs(8) {
    // read csi input data (generated by numpy)
    std::ifstream input("../../../test/beamform/csi_in.data", std::ios::binary);
    input.seekg(0, std::ios::end);
    std::streampos fileSize = input.tellg();
    input.seekg(0, std::ios::beg);

    assert(fileSize == ue * bs * sizeof(mega::Complex));
    sz_bytes = fileSize;

    std::shared_ptr<char> temp = std::shared_ptr<char>(new char[fileSize]);
    input.read(temp.get(), fileSize);
    input.close();

    csi_in = reinterpret_cast<std::shared_ptr<mega::Complex> &&>(temp);

    // read csi output data (generated by numpy)
    std::ifstream output("../../../test/beamform/csi_out.data",
                         std::ios::binary);
    output.seekg(0, std::ios::end);
    fileSize = output.tellg();
    output.seekg(0, std::ios::beg);

    assert(fileSize == sz_bytes);

    temp = std::shared_ptr<char>(new char[fileSize]);
    output.read(temp.get(), fileSize);
    output.close();

    csi_out = reinterpret_cast<std::shared_ptr<mega::Complex> &&>(temp);

    // read precoded data (generated by numpy)
    output =
        std::ifstream("../../../test/beamform/precoder.data", std::ios::binary);
    output.seekg(0, std::ios::end);
    fileSize = output.tellg();
    output.seekg(0, std::ios::beg);

    assert(fileSize == sz_bytes);

    temp = std::shared_ptr<char>(new char[fileSize]);
    output.read(temp.get(), fileSize);
    output.close();

    precoder = reinterpret_cast<std::shared_ptr<mega::Complex> &&>(temp);
  }
};

TEST_F(BeamformTest, Beamforming) {
  mega::Matrix csi(sizeof(mega::Complex), ue, bs, 2, mega::Matrix::kDevice);
  mega::Matrix prec(sizeof(mega::Complex), bs, ue, 2, mega::Matrix::kDevice);

  mega::Matrix h_csi(sizeof(mega::Complex), ue, bs, 2, mega::Matrix::kHost);
  mega::Matrix h_prec(sizeof(mega::Complex), bs, ue, 2, mega::Matrix::kHost);

  EXPECT_EQ(sz_bytes, csi.szBytes() / 2);

  cudaMemcpy(csi[0].ptr(), csi_in.get(), sz_bytes, cudaMemcpyHostToDevice);
  cudaMemcpy(csi[1].ptr(), csi_in.get(), sz_bytes, cudaMemcpyHostToDevice);

  mega::Beamform beam(bs, ue, 2);
  beam.beamformer(csi, prec);

  cudaMemcpy(h_csi.ptr(), csi.ptr(), csi.szBytes(), cudaMemcpyDeviceToHost);
  cudaMemcpy(h_prec.ptr(), prec.ptr(), prec.szBytes(), cudaMemcpyDeviceToHost);

  for (uint8_t btch = 0; btch < 2; btch++) {
    float *csi_result = h_csi[btch].ptr<float>();
    float *prec_result = h_prec[btch].ptr<float>();
    float *csi_ref = reinterpret_cast<float *>(csi_out.get());
    float *prec_ref = reinterpret_cast<float *>(precoder.get());
    for (uint32_t i = 0; i < 2 * ue * bs; i++) {
      EXPECT_NEAR(csi_result[i], csi_ref[i], 1e-5);
      EXPECT_NEAR(prec_result[i], prec_ref[i], 1e-5);
    }
  }
}