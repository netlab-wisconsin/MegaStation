/**
 * @file test_ldpc.cc
 * @author Xincheng Xie (xxc@cs.wisc.edu)
 * @brief Test cases for ldpc encoder and decoder
 * @version 0.1
 * @date 2023-11-18
 *
 * @copyright Copyright (c) 2023
 *
 */

#include <gtest/gtest.h>

#include <cassert>
#include <cstdint>
#include <fstream>
#include <functional>
#include <memory>
#include <thread>
#include <vector>

#include "ldpc/config.h"
#include "ldpc/decoder.h"
#include "ldpc/encoder.h"
#include "matrix/cuphy_tensor.h"

class LdpcTest : public testing::Test {
 protected:
  std::shared_ptr<unsigned char> inputData;
  std::shared_ptr<unsigned char> encodedData;
  short bg;
  short zc;
  short mb;
  short md_iter;
  short kb;
  int dbits;
  int ebits;
  int pbits;

  LdpcTest()
      : bg(1),
        zc(64),
        mb(46),
        md_iter(8),
        kb(22),
        dbits(1408),
        ebits(4224),
        pbits(2 * zc) {
    // read input data (generated by matlab)
    std::ifstream input("../../../test/ldpc/input.data", std::ios::binary);
    input.seekg(0, std::ios::end);
    std::streampos fileSize = input.tellg();
    input.seekg(0, std::ios::beg);

    assert(fileSize == 2 * dbits / 8);

    inputData = std::shared_ptr<unsigned char>(new unsigned char[fileSize]);
    input.read((char *)inputData.get(), fileSize);
    input.close();

    // read encode data (generated by matlab)
    std::ifstream encoded("../../../test/ldpc/encode.data", std::ios::binary);
    encoded.seekg(0, std::ios::end);
    fileSize = encoded.tellg();
    encoded.seekg(0, std::ios::beg);

    assert(fileSize == 2 * ebits / 8);

    encodedData = std::shared_ptr<unsigned char>(new unsigned char[fileSize]);
    encoded.read((char *)encodedData.get(), fileSize);
    encoded.close();
  }
};

TEST_F(LdpcTest, LDPCConfig) {
  mega::LDPCConfig config(mb, bg, zc, md_iter);
  EXPECT_EQ(config.parity_nodes, mb);
  EXPECT_EQ(config.base_graph, bg);
  EXPECT_EQ(config.lifting_factor, zc);
  EXPECT_EQ(config.max_decode_iter, md_iter);
  EXPECT_EQ(config.info_nodes, kb);
  EXPECT_EQ(config.encoded_bits, ebits);
  EXPECT_EQ(config.decoded_bits, dbits);
  EXPECT_EQ(config.punctured_bits, pbits);
}

TEST_F(LdpcTest, LDPCEncoderVec) {
  mega::LDPCConfig config(mb, bg, zc, md_iter);

  mega::CuphyTensor input_cpu(mega::CuphyTensor::kBit, config.decoded_bits,
                              mega::Matrix::kDesc, mega::CuphyTensor::kDefault,
                              inputData);
  EXPECT_EQ(input_cpu.szBytes(), config.decoded_bits / 8);
  mega::CuphyTensor input(mega::CuphyTensor::kBit, config.decoded_bits,
                          mega::Matrix::kDevice);
  EXPECT_EQ(input_cpu.ptr(), inputData.get());
  cudaMemcpy(input.ptr(), input_cpu.ptr(), input.szBytes(),
             cudaMemcpyHostToDevice);

  mega::CuphyTensor encoded_cpu(mega::CuphyTensor::kBit, config.encoded_bits,
                                mega::Matrix::kHost);
  mega::CuphyTensor encoded(mega::CuphyTensor::kBit, config.encoded_bits,
                            mega::Matrix::kDevice);
  mega::LDPCEncoder encoder(config);
  encoder(input, encoded);
  cudaMemcpy(encoded_cpu.ptr(), encoded.ptr(), encoded.szBytes(),
             cudaMemcpyDeviceToHost);

  unsigned char *encoded_cpu_ptr = encoded_cpu.ptr<unsigned char>();
  for (int i = 0; i < config.encoded_bits / 8; i++) {
    EXPECT_EQ(encoded_cpu_ptr[i], encodedData.get()[i]);
  }
}

TEST_F(LdpcTest, LDPCEncoderArr) {
  mega::LDPCConfig config(mb, bg, zc, md_iter);

  mega::CuphyTensor input_cpu(mega::CuphyTensor::kBit, config.decoded_bits, 2,
                              mega::Matrix::kDesc, mega::CuphyTensor::kDefault,
                              inputData);
  EXPECT_EQ(input_cpu.szBytes(), 2 * config.decoded_bits / 8);
  mega::CuphyTensor input(mega::CuphyTensor::kBit, config.decoded_bits, 2,
                          mega::Matrix::kDevice);
  cudaMemcpy(input.ptr(), input_cpu.ptr(), input.szBytes(),
             cudaMemcpyHostToDevice);

  mega::CuphyTensor encoded_cpu(mega::CuphyTensor::kBit, config.encoded_bits, 2,
                                mega::Matrix::kHost);
  mega::CuphyTensor encoded(mega::CuphyTensor::kBit, config.encoded_bits, 2,
                            mega::Matrix::kDevice);
  mega::LDPCEncoder encoder(config);
  encoder(input, encoded);
  cudaMemcpy(encoded_cpu.ptr(), encoded.ptr(), encoded.szBytes(),
             cudaMemcpyDeviceToHost);

  unsigned char *encoded_cpu_ptr = encoded_cpu.ptr<unsigned char>();
  for (int i = 0; i < 2 * config.encoded_bits / 8; i++) {
    EXPECT_EQ(encoded_cpu_ptr[i], encodedData.get()[i]);
  }
}

TEST_F(LdpcTest, LDPCEncoderArr2) {
  mega::LDPCConfig config(46, 1, 96, md_iter);

  mega::CuphyTensor input(mega::CuphyTensor::kBit, config.decoded_bits, 32,
                          mega::Matrix::kDevice);
  mega::CuphyTensor encoded(mega::CuphyTensor::kBit, config.encoded_bits, 32,
                            mega::Matrix::kDevice);
  mega::LDPCEncoder encoder;
  encoder = mega::LDPCEncoder(config);
  encoder(input, encoded);
}

TEST_F(LdpcTest, LDPCDecoderVec) {
  mega::LDPCConfig config(mb, bg, zc, md_iter);
  mega::LDPCDecoder decoder(mega::CuphyTensor::kFloat, config);

  mega::CuphyTensor llr_cpu(mega::CuphyTensor::kFloat,
                            config.encoded_bits + config.punctured_bits,
                            mega::Matrix::kHost);
  EXPECT_EQ(llr_cpu.szBytes(),
            (config.encoded_bits + config.punctured_bits) * sizeof(float));
  mega::CuphyTensor llr(mega::CuphyTensor::kFloat,
                        config.encoded_bits + config.punctured_bits,
                        mega::Matrix::kDevice);
  float *llr_cpu_ptr = llr_cpu.ptr<float>();
  for (int i = 0; i < config.encoded_bits; i++) {
    uint8_t bit = ((uint8_t *)encodedData.get())[i / 8] & (1 << (i % 8));
    llr_cpu_ptr[i + config.punctured_bits] = bit ? -127.0f : 127.0f;
  }
  cudaMemcpy(llr.ptr(), llr_cpu.ptr(), llr.szBytes(), cudaMemcpyHostToDevice);

  mega::CuphyTensor decoded_cpu(mega::CuphyTensor::kBit, config.decoded_bits,
                                mega::Matrix::kHost);
  mega::CuphyTensor decoded(mega::CuphyTensor::kBit, config.decoded_bits,
                            mega::Matrix::kDevice);
  mega::CuphyTensor decoded_desc(mega::CuphyTensor::kBit, config.decoded_bits,
                                 mega::Matrix::kDesc,
                                 mega::CuphyTensor::kCoalesce);
  EXPECT_EQ(decoded.szBytes(), config.decoded_bits / 8);
  EXPECT_EQ(decoded.szBytes(), decoded_desc.szBytes());
  decoder(llr, decoded);
  cudaMemcpy(decoded_cpu.ptr(), decoded.ptr(), decoded.szBytes(),
             cudaMemcpyDeviceToHost);

  unsigned char *decoded_cpu_ptr = decoded_cpu.ptr<unsigned char>();
  for (int i = 0; i < config.decoded_bits / 8; i++) {
    EXPECT_EQ(decoded_cpu_ptr[i], inputData.get()[i]);
  }
}

TEST_F(LdpcTest, LDPCDecoderArr) {
  mega::LDPCConfig config(mb, bg, zc, md_iter);
  mega::LDPCDecoder decoder(mega::CuphyTensor::kFloat, config);

  mega::CuphyTensor llr_cpu(mega::CuphyTensor::kFloat,
                            config.encoded_bits + config.punctured_bits, 2,
                            mega::Matrix::kHost);
  EXPECT_EQ(llr_cpu.szBytes(),
            2 * (config.encoded_bits + config.punctured_bits) * sizeof(float));
  mega::CuphyTensor llr(mega::CuphyTensor::kFloat,
                        config.encoded_bits + config.punctured_bits, 2,
                        mega::Matrix::kDevice);
  for (int j = 0; j < 2; j++) {
    float *llr_cpu_ptr = llr_cpu[j].ptr<float>();
    unsigned char *encoded_data_ptr = &encodedData.get()[j * ebits / 8];
    for (int i = 0; i < config.encoded_bits; i++) {
      unsigned char bit = encoded_data_ptr[i / 8] & (1 << (i % 8));
      llr_cpu_ptr[i + config.punctured_bits] = bit ? -127.0f : 127.0f;
    }
  }
  cudaMemcpy(llr.ptr(), llr_cpu.ptr(), llr.szBytes(), cudaMemcpyHostToDevice);

  mega::CuphyTensor decoded_cpu(mega::CuphyTensor::kBit, config.decoded_bits, 2,
                                mega::Matrix::kHost);
  mega::CuphyTensor decoded(mega::CuphyTensor::kBit, config.decoded_bits, 2,
                            mega::Matrix::kDevice);
  mega::CuphyTensor decoded_desc(mega::CuphyTensor::kBit, config.decoded_bits,
                                 2, mega::Matrix::kDesc,
                                 mega::CuphyTensor::kCoalesce);
  EXPECT_EQ(decoded.szBytes(), 2 * config.decoded_bits / 8);
  EXPECT_NE(decoded.szBytes(), decoded_desc.szBytes());
  decoder(llr, decoded);
  cudaMemcpy(decoded_cpu.ptr(), decoded.ptr(), decoded.szBytes(),
             cudaMemcpyDeviceToHost);

  for (int j = 0; j < 2; j++) {
    unsigned char *decoded_cpu_ptr = decoded_cpu[j].ptr<unsigned char>();
    unsigned char *input_data_ptr = &inputData.get()[j * dbits / 8];
    for (int i = 0; i < config.decoded_bits / 8; i++) {
      EXPECT_EQ(decoded_cpu_ptr[i], input_data_ptr[i]);
    }
  }
}

TEST(LdpcTestI, LdpcIntegrated) {
  const int batch = 16;
  const int round = 13;
  mega::LDPCConfig config(46, 1, 96, 8);
  mega::LDPCDecoder decoder(mega::CuphyTensor::kFloat, config);
  for (int k = 0; k < round; k++) {
    mega::CuphyTensor input_cpu(mega::CuphyTensor::kBit, config.decoded_bits,
                                batch, mega::Matrix::kHost);
    mega::CuphyTensor input(mega::CuphyTensor::kBit, config.decoded_bits, batch,
                            mega::Matrix::kDevice);
    srand(time(NULL));
    for (int j = 0; j < batch; j++) {
      for (int i = 0; i < config.decoded_bits / 8; i++) {
        input_cpu[j].deref<int8_t>(i) = static_cast<int8_t>(rand());
      }
    }
    cudaMemcpy(input.ptr(), input_cpu.ptr(), input.szBytes(),
               cudaMemcpyHostToDevice);
    mega::CuphyTensor encoded(mega::CuphyTensor::kBit, config.encoded_bits,
                              batch, mega::Matrix::kDevice);
    mega::LDPCEncoder encoder(config);
    encoder(input, encoded);
    mega::CuphyTensor encoded_cpu(mega::CuphyTensor::kBit, config.encoded_bits,
                                  batch, mega::Matrix::kHost);
    cudaMemcpy(encoded_cpu.ptr(), encoded.ptr(), encoded.szBytes(),
               cudaMemcpyDeviceToHost);

    mega::CuphyTensor llrs(mega::CuphyTensor::kFloat,
                           config.encoded_bits + config.punctured_bits, batch,
                           mega::Matrix::kDevice, mega::CuphyTensor::kCoalesce);
    mega::CuphyTensor llrs_cpu(
        mega::CuphyTensor::kFloat, config.encoded_bits + config.punctured_bits,
        batch, mega::Matrix::kHost, mega::CuphyTensor::kCoalesce);
    for (int j = 0; j < batch; j++) {
      float *llrs_cpu_ptr = llrs_cpu[j].ptr<float>();
      uint8_t *encoded_cpu_ptr = encoded_cpu[j].ptr<uint8_t>();
      for (int i = 0; i < config.encoded_bits; i++) {
        uint8_t bit = encoded_cpu_ptr[i / 8] & (1 << (i % 8));
        llrs_cpu_ptr[i + config.punctured_bits] = bit ? -127.0f : 127.0f;
      }
    }
    cudaMemcpy(llrs.ptr(), llrs_cpu.ptr(), llrs.szBytes(),
               cudaMemcpyHostToDevice);
    mega::CuphyTensor output(mega::CuphyTensor::kBit, config.decoded_bits,
                             batch, mega::Matrix::kDevice,
                             mega::CuphyTensor::kCoalesce);
    decoder(llrs, output);
    mega::CuphyTensor output_cpu(mega::CuphyTensor::kBit, config.decoded_bits,
                                 batch, mega::Matrix::kHost,
                                 mega::CuphyTensor::kCoalesce);
    cudaMemcpy(output_cpu.ptr(), output.ptr(), output.szBytes(),
               cudaMemcpyDeviceToHost);

    for (int j = 0; j < batch; j++) {
      uint8_t *input_cpu_ptr = input_cpu[j].ptr<uint8_t>();
      uint8_t *output_cpu_ptr = output_cpu[j].ptr<uint8_t>();
      for (int i = 0; i < config.decoded_bits / 8; i++) {
        EXPECT_EQ(input_cpu_ptr[i], output_cpu_ptr[i]);
      }
    }
  }
}

void thread_encoder(mega::LDPCConfig &config, mega::LDPCEncoder &encoder,
                    mega::CuphyTensor &input_cpu, mega::CuphyTensor &input,
                    mega::CuphyTensor &encoded_cpu, mega::CuphyTensor &encoded,
                    cudaStream_t &stream) {
  cudaMemcpyAsync(input.ptr(), input_cpu.ptr(), input.szBytes(),
                  cudaMemcpyHostToDevice, stream);
  encoder(input, encoded, stream);
  cudaMemcpyAsync(encoded_cpu.ptr(), encoded.ptr(), encoded.szBytes(),
                  cudaMemcpyDeviceToHost, stream);
}

TEST(LdpcTestI, LdpcIntegratedEncoderThreads) {
  const int batch = 16;
  const int round = 13;

  std::vector<std::thread> threads;
  std::vector<mega::CuphyTensor> input_cpu;
  std::vector<mega::CuphyTensor> input_gpu;
  std::vector<mega::CuphyTensor> encoded_cpu;
  std::vector<mega::CuphyTensor> encoded_gpu;
  std::vector<mega::LDPCConfig> configs;
  std::vector<mega::LDPCEncoder> encoders;
  std::vector<cudaStream_t> streams;

  for (int i = 0; i < round; i++) {
    mega::LDPCConfig config_i(46, 1, 96, 8);
    mega::CuphyTensor input_cpu_i(mega::CuphyTensor::kBit,
                                  config_i.decoded_bits, batch,
                                  mega::Matrix::kHost);
    mega::CuphyTensor input_gpu_i(mega::CuphyTensor::kBit,
                                  config_i.decoded_bits, batch,
                                  mega::Matrix::kDevice);
    mega::CuphyTensor encoded_cpu_i(mega::CuphyTensor::kBit,
                                    config_i.encoded_bits, batch,
                                    mega::Matrix::kHost);
    mega::CuphyTensor encoded_gpu_i(mega::CuphyTensor::kBit,
                                    config_i.encoded_bits, batch,
                                    mega::Matrix::kDevice);
    mega::LDPCEncoder encoder_i(config_i);
    cudaStream_t stream_i;
    cudaStreamCreateWithFlags(&stream_i, cudaStreamNonBlocking);

    srand(time(NULL));
    for (int j = 0; j < batch; j++) {
      for (int i = 0; i < config_i.decoded_bits / 8; i++) {
        ((int8_t *)input_cpu_i[j].ptr())[i] = static_cast<int8_t>(rand());
      }
    }

    input_cpu.push_back(input_cpu_i);
    input_gpu.push_back(input_gpu_i);
    encoded_cpu.push_back(encoded_cpu_i);
    encoded_gpu.push_back(encoded_gpu_i);
    configs.push_back(config_i);
    encoders.push_back(encoder_i);
    streams.push_back(stream_i);
  }

  for (int i = 0; i < round; i++) {
    threads.emplace_back(
        std::thread(thread_encoder, std::ref(configs[i]), std::ref(encoders[i]),
                    std::ref(input_cpu[i]), std::ref(input_gpu[i]),
                    std::ref(encoded_cpu[i]), std::ref(encoded_gpu[i]),
                    std::ref(streams[i])));
  }

  for (int i = 0; i < round; i++) {
    threads[i].join();
  }

  for (auto &stream : streams) {
    cudaStreamDestroy(stream);
  }
}