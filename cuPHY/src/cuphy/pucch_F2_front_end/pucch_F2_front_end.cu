/*
 * Copyright (c) 2021-2023, NVIDIA CORPORATION & AFFILIATES.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */

 #include "pucch_F2_front_end.hpp"
 #include "descrambling.cuh"
 #include <cooperative_groups.h>
 #include <cooperative_groups/reduce.h>
 #include <functional>
 #include "cuComplex.h"
 #include "cuda_fp16.h"
 #include "math_utils.cuh"
 #include "cuphy.hpp"

 #include <math.h>
 #include <iostream>
 namespace cg = cooperative_groups;

 bool pucchF2Rx::isConstMemInited = false;
std::mutex pucchF2Rx::m_mutexConstMemInit;

namespace pucch_F2
{
template <typename TElem>
struct tensor_ref
{
    TElem*         addr;
    const int32_t* strides;

    CUDA_BOTH
    tensor_ref(void* pAddr, const int32_t* pStrides) :
        addr(static_cast<TElem*>(pAddr)),
        strides(pStrides)
    {
    }
    CUDA_BOTH long offset(int i0) const
    {
        return (strides[0] * (long)i0);
    }
    CUDA_BOTH long offset(int i0, int i1) const
    {
        return (strides[0] * (long)i0) + (strides[1] * (long)i1);
    }
    CUDA_BOTH long offset(int i0, int i1, int i2) const
    {
        return (strides[0] * (long)i0) + (strides[1] * (long)i1) + (strides[2] * (long)i2);
    };
    CUDA_BOTH long offset(int i0, int i1, int i2, int i3) const
    {
        return (strides[0] * (long)i0) + (strides[1] * (long)i1) + (strides[2] * (long)i2) + (strides[3] * (long)i3);
    };
    // clang-format off
    CUDA_BOTH TElem&       operator()(int i0)                               { return *(addr + offset(i0));         }
    CUDA_BOTH TElem&       operator()(int i0, int i1)                       { return *(addr + offset(i0, i1));     }
    CUDA_BOTH TElem&       operator()(int i0, int i1, int i2)               { return *(addr + offset(i0, i1, i2)); }
    CUDA_BOTH TElem&       operator()(int i0, int i1, int i2, int i3)       { return *(addr + offset(i0, i1, i2, i3)); }

    CUDA_BOTH const TElem& operator()(int i0) const                         { return *(addr + offset(i0));         }
    CUDA_BOTH const TElem& operator()(int i0, int i1) const                 { return *(addr + offset(i0, i1));     }
    CUDA_BOTH const TElem& operator()(int i0, int i1, int i2) const         { return *(addr + offset(i0, i1, i2)); }
    CUDA_BOTH const TElem& operator()(int i0, int i1, int i2, int i3) const { return *(addr + offset(i0, i1, i2, i3)); }
    // clang-format on
};

// Lookup tables in constant memory. Some of these are stored either transposed or the conjugate of the MATLAB version
// since they're only used in that format.
static __device__ __constant__ __half2 d_W1[12][4];
static __half2                         W1[12][4] = {{{0.864258, 0.173828}, {0.161621, 0.164307}, {-0.021210, -0.115601}, {0.039398, -0.089661}},
                            {{0.733887, 0.000000}, {0.256592, 0.173828}, {0.002087, 0.005226}, {0.022720, -0.103760}},
                            {{0.574707, -0.115601}, {0.340088, 0.142578}, {0.065186, 0.099854}, {0.001574, -0.092041}},
                            {{0.408936, -0.171387}, {0.396240, 0.079712}, {0.153564, 0.156250}, {-0.009880, -0.053864}},
                            {{0.256592, -0.173828}, {0.415039, 0.000000}, {0.249390, 0.168945}, {0.002087, 0.005226}},
                            {{0.133423, -0.135742}, {0.393311, -0.079102}, {0.334473, 0.140259}, {0.048096, 0.073669}},
                            {{0.048096, -0.073669}, {0.334473, -0.140259}, {0.393311, 0.079102}, {0.133423, 0.135742}},
                            {{0.002087, -0.005226}, {0.249390, -0.168945}, {0.415039, 0.000000}, {0.256592, 0.173828}},
                            {{-0.009880, 0.053864}, {0.153564, -0.156250}, {0.396240, -0.079712}, {0.408936, 0.171387}},
                            {{0.001574, 0.092041}, {0.065186, -0.099854}, {0.340088, -0.142578}, {0.574707, 0.115601}},
                            {{0.022720, 0.103760}, {0.002087, -0.005226}, {0.256592, -0.173828}, {0.733887, 0.000000}},
                            {{0.039398, 0.089661}, {-0.021210, 0.115601}, {0.161621, -0.164307}, {0.864258, -0.173828}}};

static __device__ __constant__ __half2 d_W2[24][8];
static __half2                         W2[24][8] = {{{0.819336, 0.164795}, {0.203003, 0.206421}, {-0.008530, -0.046478}, {0.061768, -0.140503}, {0.077881, -0.048981}, {-0.023880, -0.000817}, {-0.064392, -0.046906}, {-0.001843, -0.005119}},
                            {{0.701172, 0.000000}, {0.268799, 0.182129}, {0.019196, 0.048065}, {0.016769, -0.076599}, {0.059540, -0.056580}, {0.018326, -0.003038}, {-0.034332, -0.015793}, {-0.014587, -0.024109}},
                            {{0.557617, -0.112183}, {0.319824, 0.134033}, {0.076294, 0.116821}, {0.000060, -0.003525}, {0.035797, -0.050934}, {0.045685, -0.017349}, {-0.000239, -0.000057}, {-0.027664, -0.030136}},
                            {{0.407959, -0.171021}, {0.348145, 0.070068}, {0.149658, 0.152344}, {0.012360, 0.067383}, {0.013412, -0.030518}, {0.055817, -0.035095}, {0.031128, 0.001064}, {-0.035461, -0.025833}},
                            {{0.268799, -0.182129}, {0.350830, 0.000000}, {0.225220, 0.152588}, {0.050171, 0.125610}, {-0.000679, 0.003098}, {0.050262, -0.047760}, {0.054077, -0.008965}, {-0.034332, -0.015793}},
                            {{0.153687, -0.156250}, {0.327881, -0.065979}, {0.289551, 0.121338}, {0.106323, 0.162842}, {-0.000778, 0.045502}, {0.034119, -0.048584}, {0.065002, -0.024673}, {-0.023422, -0.005550}},
                            {{0.069824, -0.106934}, {0.283691, -0.118958}, {0.332031, 0.066772}, {0.171265, 0.174194}, {0.016525, 0.090088}, {0.014854, -0.033783}, {0.063049, -0.039642}, {-0.004513, -0.000154}},
                            {{0.019196, -0.048065}, {0.225220, -0.152588}, {0.346680, 0.000000}, {0.234497, 0.158936}, {0.051605, 0.129150}, {0.000756, -0.003450}, {0.050262, -0.047760}, {0.018326, -0.003038}},
                            {{-0.001405, 0.007660}, {0.161133, -0.163940}, {0.332275, -0.066833}, {0.286133, 0.119995}, {0.101563, 0.155518}, {-0.000661, 0.038696}, {0.031158, -0.044342}, {0.039825, -0.015121}},
                            {{0.000871, 0.050964}, {0.100342, -0.153687}, {0.292236, -0.122559}, {0.318604, 0.064087}, {0.160645, 0.163330}, {0.015732, 0.085815}, {0.011940, -0.027176}, {0.054840, -0.034485}},
                            {{0.016769, 0.076599}, {0.050171, -0.125610}, {0.234497, -0.158936}, {0.327148, 0.000000}, {0.220947, 0.149658}, {0.051605, 0.129150}, {-0.000679, 0.003098}, {0.059540, -0.056580}},
                            {{0.036804, 0.083740}, {0.015808, -0.086182}, {0.168457, -0.171387}, {0.311279, -0.062622}, {0.273926, 0.114807}, {0.104553, 0.160156}, {-0.000733, 0.042877}, {0.052856, -0.075195}},
                            {{0.052856, 0.075195}, {-0.000733, -0.042877}, {0.104553, -0.160156}, {0.273926, -0.114807}, {0.311279, 0.062622}, {0.168457, 0.171387}, {0.015808, 0.086182}, {0.036804, -0.083740}},
                            {{0.059540, 0.056580}, {-0.000679, -0.003098}, {0.051605, -0.129150}, {0.220947, -0.149658}, {0.327148, 0.000000}, {0.234497, 0.158936}, {0.050171, 0.125610}, {0.016769, -0.076599}},
                            {{0.054840, 0.034485}, {0.011940, 0.027176}, {0.015732, -0.085815}, {0.160645, -0.163330}, {0.318604, -0.064087}, {0.292236, 0.122559}, {0.100342, 0.153687}, {0.000871, -0.050964}},
                            {{0.039825, 0.015121}, {0.031158, 0.044342}, {-0.000661, -0.038696}, {0.101563, -0.155518}, {0.286133, -0.119995}, {0.332275, 0.066833}, {0.161133, 0.163940}, {-0.001405, -0.007660}},
                            {{0.018326, 0.003038}, {0.050262, 0.047760}, {0.000756, 0.003450}, {0.051605, -0.129150}, {0.234497, -0.158936}, {0.346680, 0.000000}, {0.225220, 0.152588}, {0.019196, 0.048065}},
                            {{-0.004513, 0.000154}, {0.063049, 0.039642}, {0.014854, 0.033783}, {0.016525, -0.090088}, {0.171265, -0.174194}, {0.332031, -0.066772}, {0.283691, 0.118958}, {0.069824, 0.106934}},
                            {{-0.023422, 0.005550}, {0.065002, 0.024673}, {0.034119, 0.048584}, {-0.000778, -0.045502}, {0.106323, -0.162842}, {0.289551, -0.121338}, {0.327881, 0.065979}, {0.153687, 0.156250}},
                            {{-0.034332, 0.015793}, {0.054077, 0.008965}, {0.050262, 0.047760}, {-0.000679, -0.003098}, {0.050171, -0.125610}, {0.225220, -0.152588}, {0.350830, 0.000000}, {0.268799, 0.182129}},
                            {{-0.035461, 0.025833}, {0.031128, -0.001064}, {0.055817, 0.035095}, {0.013412, 0.030518}, {0.012360, -0.067383}, {0.149658, -0.152344}, {0.348145, -0.070068}, {0.407959, 0.171021}},
                            {{-0.027664, 0.030136}, {-0.000239, 0.000057}, {0.045685, 0.017349}, {0.035797, 0.050934}, {0.000060, 0.003525}, {0.076294, -0.116821}, {0.319824, -0.134033}, {0.557617, 0.112183}},
                            {{-0.014587, 0.024109}, {-0.034332, 0.015793}, {0.018326, 0.003038}, {0.059540, 0.056580}, {0.016769, 0.076599}, {0.019196, -0.048065}, {0.268799, -0.182129}, {0.701172, 0.000000}},
                            {{-0.001843, 0.005119}, {-0.064392, 0.046906}, {-0.023880, 0.000817}, {0.077881, 0.048981}, {0.061768, 0.140503}, {-0.008530, 0.046478}, {0.203003, -0.206421}, {0.819336, -0.164795}}};

static __device__ __constant__ __half2 d_W3[36][12];
static __half2                         W3[36][12] = {{{0.797852, 0.160400}, {0.215210, 0.218994}, {-0.003225, -0.017578}, {0.057648, -0.131226}, {0.098938, -0.062195}, {0.022461, 0.000768}, {-0.046875, -0.034149}, {-0.026077, -0.072388}, {0.008659, -0.033966}, {-0.019897, 0.017639}, {-0.050812, 0.006649}, {0.002756, 0.001384}},
                             {{0.686523, 0.000000}, {0.274414, 0.185791}, {0.025620, 0.064148}, {0.014343, -0.065491}, {0.064880, -0.061646}, {0.042969, -0.007122}, {-0.014404, -0.006626}, {-0.024368, -0.040253}, {0.001878, -0.036591}, {0.000371, -0.000491}, {-0.025726, 0.008774}, {-0.013306, -0.003637}},
                             {{0.550781, -0.110779}, {0.317383, 0.133057}, {0.079468, 0.121765}, {-0.000121, 0.007092}, {0.031982, -0.045502}, {0.050842, -0.019302}, {0.018295, 0.004333}, {-0.012138, -0.013222}, {-0.004810, -0.032440}, {0.008995, -0.018707}, {-0.004860, 0.002829}, {-0.024200, -0.001657}},
                             {{0.407959, -0.171021}, {0.338867, 0.068176}, {0.146729, 0.149292}, {0.013855, 0.075500}, {0.006657, -0.015144}, {0.046478, -0.029221}, {0.044678, 0.001528}, {0.007179, 0.005230}, {-0.008240, -0.022888}, {0.008286, -0.032471}, {0.009315, -0.008263}, {-0.028275, 0.003700}},
                             {{0.274414, -0.185791}, {0.336914, 0.000000}, {0.214844, 0.145508}, {0.051880, 0.130005}, {-0.005562, 0.025391}, {0.033020, -0.031372}, {0.060181, -0.009979}, {0.029053, 0.013367}, {-0.006348, -0.010490}, {0.001995, -0.038879}, {0.015854, -0.020996}, {-0.025726, 0.008774}},
                             {{0.161865, -0.164673}, {0.312500, -0.062866}, {0.272461, 0.114197}, {0.106445, 0.163086}, {-0.001201, 0.070251}, {0.015610, -0.022217}, {0.062927, -0.023880}, {0.048767, 0.011559}, {0.001443, 0.001572}, {-0.005505, -0.037140}, {0.015358, -0.031952}, {-0.018234, 0.010612}},
                             {{0.078247, -0.119873}, {0.269531, -0.113037}, {0.310547, 0.062439}, {0.168091, 0.171021}, {0.020630, 0.112488}, {0.000376, -0.000856}, {0.053833, -0.033844}, {0.062195, 0.002127}, {0.014122, 0.010284}, {-0.010216, -0.028366}, {0.009796, -0.038422}, {-0.008530, 0.007565}},
                             {{0.025620, -0.064148}, {0.214844, -0.145508}, {0.323975, 0.000000}, {0.227051, 0.153809}, {0.058014, 0.145386}, {-0.006741, 0.030792}, {0.036560, -0.034729}, {0.066711, -0.011055}, {0.029343, 0.013496}, {-0.009285, -0.015343}, {0.001995, -0.038879}, {0.000371, -0.000491}},
                             {{0.001700, -0.009270}, {0.155518, -0.158203}, {0.312256, -0.062805}, {0.274170, 0.114929}, {0.106567, 0.163330}, {-0.001168, 0.068359}, {0.016495, -0.023483}, {0.061493, -0.023346}, {0.043976, 0.010422}, {-0.001596, -0.001740}, {-0.004944, -0.033325}, {0.005875, -0.012215}},
                             {{0.000611, 0.035767}, {0.099182, -0.151978}, {0.277832, -0.116455}, {0.302979, 0.060944}, {0.160034, 0.162842}, {0.019424, 0.105896}, {-0.000120, 0.000273}, {0.047943, -0.030151}, {0.054779, 0.001873}, {0.012093, 0.008812}, {-0.008308, -0.023071}, {0.006428, -0.025208}},
                             {{0.014343, 0.065491}, {0.051880, -0.130005}, {0.227051, -0.153809}, {0.309814, 0.000000}, {0.211182, 0.143066}, {0.054596, 0.136719}, {-0.007473, 0.034119}, {0.029312, -0.027847}, {0.059143, -0.009804}, {0.029343, 0.013496}, {-0.006348, -0.010490}, {0.001878, -0.036591}},
                             {{0.034363, 0.078186}, {0.017883, -0.097534}, {0.167969, -0.170898}, {0.294189, -0.059204}, {0.253174, 0.106140}, {0.101196, 0.155029}, {-0.001254, 0.073364}, {0.010208, -0.014519}, {0.055786, -0.021164}, {0.046631, 0.011047}, {0.001392, 0.001516}, {-0.006496, -0.043793}},
                             {{0.053070, 0.075500}, {-0.001038, -0.060669}, {0.109070, -0.167114}, {0.259521, -0.108826}, {0.280029, 0.056335}, {0.153809, 0.156494}, {0.020508, 0.111755}, {-0.004242, 0.009659}, {0.045105, -0.028351}, {0.060150, 0.002056}, {0.013931, 0.010147}, {-0.016251, -0.045135}},
                             {{0.064880, 0.061646}, {-0.005562, -0.025391}, {0.058014, -0.145386}, {0.211182, -0.143066}, {0.288330, 0.000000}, {0.205444, 0.139160}, {0.056976, 0.142700}, {-0.009262, 0.042297}, {0.029312, -0.027847}, {0.066711, -0.011055}, {0.029053, 0.013367}, {-0.024368, -0.040253}},
                             {{0.066895, 0.042084}, {0.001521, 0.003460}, {0.020340, -0.110901}, {0.156128, -0.158813}, {0.277100, -0.055756}, {0.249146, 0.104431}, {0.104614, 0.160278}, {-0.001352, 0.079102}, {0.012161, -0.017303}, {0.064514, -0.024475}, {0.043793, 0.010384}, {-0.027908, -0.030411}},
                             {{0.058899, 0.022354}, {0.015991, 0.022751}, {-0.001204, -0.070435}, {0.101746, -0.155884}, {0.248169, -0.104065}, {0.278564, 0.056030}, {0.157715, 0.160400}, {0.021011, 0.114502}, {-0.001695, 0.003857}, {0.053680, -0.033752}, {0.055054, 0.001883}, {-0.024826, -0.018082}},
                             {{0.042969, 0.007122}, {0.033020, 0.031372}, {-0.006741, -0.030792}, {0.054596, -0.136719}, {0.205444, -0.139160}, {0.289551, 0.000000}, {0.209229, 0.141724}, {0.056976, 0.142700}, {-0.007473, 0.034119}, {0.036560, -0.034729}, {0.060181, -0.009979}, {-0.014404, -0.006626}},
                             {{0.022705, -0.000776}, {0.048126, 0.030258}, {0.000947, 0.002153}, {0.019470, -0.106201}, {0.155029, -0.157715}, {0.280273, -0.056366}, {0.252197, 0.105713}, {0.103333, 0.158325}, {-0.001196, 0.069946}, {0.017212, -0.024506}, {0.057831, -0.021942}, {0.002314, 0.000548}},
                             {{0.002314, -0.000548}, {0.057831, 0.021942}, {0.017212, 0.024506}, {-0.001196, -0.069946}, {0.103333, -0.158325}, {0.252197, -0.105713}, {0.280273, 0.056366}, {0.155029, 0.157715}, {0.019470, 0.106201}, {0.000947, -0.002153}, {0.048126, -0.030258}, {0.022705, 0.000776}},
                             {{-0.014404, 0.006626}, {0.060181, 0.009979}, {0.036560, 0.034729}, {-0.007473, -0.034119}, {0.056976, -0.142700}, {0.209229, -0.141724}, {0.289551, 0.000000}, {0.205444, 0.139160}, {0.054596, 0.136719}, {-0.006741, 0.030792}, {0.033020, -0.031372}, {0.042969, -0.007122}},
                             {{-0.024826, 0.018082}, {0.055054, -0.001883}, {0.053680, 0.033752}, {-0.001695, -0.003857}, {0.021011, -0.114502}, {0.157715, -0.160400}, {0.278564, -0.056030}, {0.248169, 0.104065}, {0.101746, 0.155884}, {-0.001204, 0.070435}, {0.015991, -0.022751}, {0.058899, -0.022354}},
                             {{-0.027908, 0.030411}, {0.043793, -0.010384}, {0.064514, 0.024475}, {0.012161, 0.017303}, {-0.001352, -0.079102}, {0.104614, -0.160278}, {0.249146, -0.104431}, {0.277100, 0.055756}, {0.156128, 0.158813}, {0.020340, 0.110901}, {0.001521, -0.003460}, {0.066895, -0.042084}},
                             {{-0.024368, 0.040253}, {0.029053, -0.013367}, {0.066711, 0.011055}, {0.029312, 0.027847}, {-0.009262, -0.042297}, {0.056976, -0.142700}, {0.205444, -0.139160}, {0.288330, 0.000000}, {0.211182, 0.143066}, {0.058014, 0.145386}, {-0.005562, 0.025391}, {0.064880, -0.061646}},
                             {{-0.016251, 0.045135}, {0.013931, -0.010147}, {0.060150, -0.002056}, {0.045105, 0.028351}, {-0.004242, -0.009659}, {0.020508, -0.111755}, {0.153809, -0.156494}, {0.280029, -0.056335}, {0.259521, 0.108826}, {0.109070, 0.167114}, {-0.001038, 0.060669}, {0.053070, -0.075500}},
                             {{-0.006496, 0.043793}, {0.001392, -0.001516}, {0.046631, -0.011047}, {0.055786, 0.021164}, {0.010208, 0.014519}, {-0.001254, -0.073364}, {0.101196, -0.155029}, {0.253174, -0.106140}, {0.294189, 0.059204}, {0.167969, 0.170898}, {0.017883, 0.097534}, {0.034363, -0.078186}},
                             {{0.001878, 0.036591}, {-0.006348, 0.010490}, {0.029343, -0.013496}, {0.059143, 0.009804}, {0.029312, 0.027847}, {-0.007473, -0.034119}, {0.054596, -0.136719}, {0.211182, -0.143066}, {0.309814, 0.000000}, {0.227051, 0.153809}, {0.051880, 0.130005}, {0.014343, -0.065491}},
                             {{0.006428, 0.025208}, {-0.008308, 0.023071}, {0.012093, -0.008812}, {0.054779, -0.001873}, {0.047943, 0.030151}, {-0.000120, -0.000273}, {0.019424, -0.105896}, {0.160034, -0.162842}, {0.302979, -0.060944}, {0.277832, 0.116455}, {0.099182, 0.151978}, {0.000611, -0.035767}},
                             {{0.005875, 0.012215}, {-0.004944, 0.033325}, {-0.001596, 0.001740}, {0.043976, -0.010422}, {0.061493, 0.023346}, {0.016495, 0.023483}, {-0.001168, -0.068359}, {0.106567, -0.163330}, {0.274170, -0.114929}, {0.312256, 0.062805}, {0.155518, 0.158203}, {0.001700, 0.009270}},
                             {{0.000371, 0.000491}, {0.001995, 0.038879}, {-0.009285, 0.015343}, {0.029343, -0.013496}, {0.066711, 0.011055}, {0.036560, 0.034729}, {-0.006741, -0.030792}, {0.058014, -0.145386}, {0.227051, -0.153809}, {0.323975, 0.000000}, {0.214844, 0.145508}, {0.025620, 0.064148}},
                             {{-0.008530, -0.007565}, {0.009796, 0.038422}, {-0.010216, 0.028366}, {0.014122, -0.010284}, {0.062195, -0.002127}, {0.053833, 0.033844}, {0.000376, 0.000856}, {0.020630, -0.112488}, {0.168091, -0.171021}, {0.310547, -0.062439}, {0.269531, 0.113037}, {0.078247, 0.119873}},
                             {{-0.018234, -0.010612}, {0.015358, 0.031952}, {-0.005505, 0.037140}, {0.001443, -0.001572}, {0.048767, -0.011559}, {0.062927, 0.023880}, {0.015610, 0.022217}, {-0.001201, -0.070251}, {0.106445, -0.163086}, {0.272461, -0.114197}, {0.312500, 0.062866}, {0.161865, 0.164673}},
                             {{-0.025726, -0.008774}, {0.015854, 0.020996}, {0.001995, 0.038879}, {-0.006348, 0.010490}, {0.029053, -0.013367}, {0.060181, 0.009979}, {0.033020, 0.031372}, {-0.005562, -0.025391}, {0.051880, -0.130005}, {0.214844, -0.145508}, {0.336914, 0.000000}, {0.274414, 0.185791}},
                             {{-0.028275, -0.003700}, {0.009315, 0.008263}, {0.008286, 0.032471}, {-0.008240, 0.022888}, {0.007179, -0.005230}, {0.044678, -0.001528}, {0.046478, 0.029221}, {0.006657, 0.015144}, {0.013855, -0.075500}, {0.146729, -0.149292}, {0.338867, -0.068176}, {0.407959, 0.171021}},
                             {{-0.024200, 0.001657}, {-0.004860, -0.002829}, {0.008995, 0.018707}, {-0.004810, 0.032440}, {-0.012138, 0.013222}, {0.018295, -0.004333}, {0.050842, 0.019302}, {0.031982, 0.045502}, {-0.000121, -0.007092}, {0.079468, -0.121765}, {0.317383, -0.133057}, {0.550781, 0.110779}},
                             {{-0.013306, 0.003637}, {-0.025726, -0.008774}, {0.000371, 0.000491}, {0.001878, 0.036591}, {-0.024368, 0.040253}, {-0.014404, 0.006626}, {0.042969, 0.007122}, {0.064880, 0.061646}, {0.014343, 0.065491}, {0.025620, -0.064148}, {0.274414, -0.185791}, {0.686523, 0.000000}},
                             {{0.002756, -0.001384}, {-0.050812, -0.006649}, {-0.019897, -0.017639}, {0.008659, 0.033966}, {-0.026077, 0.072388}, {-0.046875, 0.034149}, {0.022461, -0.000768}, {0.098938, 0.062195}, {0.057648, 0.131226}, {-0.003225, 0.017578}, {0.215210, -0.218994}, {0.797852, -0.160400}}};

#define W4_ROWS 48
#define W4_COLS 16
static __device__ __constant__ __half2 d_W4[W4_ROWS][W4_COLS];
static __half2                         W4[W4_ROWS][W4_COLS] = {{{0.785645, 0.158081}, {0.220581, 0.224487}, {-0.000592, -0.003229}, {0.054565, -0.124207}, {0.104553, -0.065735}, {0.040039, 0.001369}, {-0.033844, -0.024658}, {-0.025940, -0.072021}, {0.013939, -0.054626}, {0.004128, -0.003660}, {-0.038818, 0.005077}, {-0.044647, -0.022415}, {-0.011505, -0.020569}, {-0.001487, 0.017349}, {-0.022751, 0.028076}, {-0.000733, 0.000222}},
                                       {{0.678223, 0.000000}, {0.276855, 0.187500}, {0.028854, 0.072266}, {0.012917, -0.058990}, {0.065796, -0.062561}, {0.052155, -0.008652}, {-0.004036, -0.001857}, {-0.022034, -0.036407}, {0.002319, -0.045166}, {0.011780, -0.015602}, {-0.012413, 0.004230}, {-0.029953, -0.008186}, {-0.015945, -0.018600}, {-0.000104, -0.000914}, {-0.008804, 0.016800}, {-0.010483, 0.005630}},
                                       {{0.546875, -0.109924}, {0.316650, 0.132690}, {0.081299, 0.124512}, {-0.000207, 0.012100}, {0.030334, -0.043152}, {0.052734, -0.020020}, {0.024551, 0.005817}, {-0.007465, -0.008133}, {-0.004532, -0.030563}, {0.011917, -0.024780}, {0.006893, -0.004013}, {-0.012924, -0.000885}, {-0.017273, -0.013519}, {-0.004360, -0.013542}, {-0.001096, 0.003754}, {-0.014175, 0.011734}},
                                       {{0.407715, -0.170898}, {0.335449, 0.067444}, {0.145630, 0.148193}, {0.014381, 0.078430}, {0.004395, -0.010002}, {0.043091, -0.027084}, {0.046173, 0.001579}, {0.013405, 0.009766}, {-0.004910, -0.013634}, {0.007320, -0.028702}, {0.017624, -0.015625}, {0.003372, -0.000441}, {-0.014740, -0.007401}, {-0.010956, -0.019592}, {0.000723, -0.008438}, {-0.012955, 0.015991}},
                                       {{0.276855, -0.187500}, {0.331299, 0.000000}, {0.210327, 0.142456}, {0.052124, 0.130615}, {-0.007072, 0.032318}, {0.026794, -0.025467}, {0.057190, -0.009483}, {0.035492, 0.016327}, {0.001443, 0.002384}, {0.001358, -0.026459}, {0.020096, -0.026611}, {0.016281, -0.005550}, {-0.008614, -0.002356}, {-0.016769, -0.019577}, {-0.002003, -0.017654}, {-0.008804, 0.016800}},
                                       {{0.165894, -0.168823}, {0.306152, -0.061584}, {0.264648, 0.110962}, {0.105530, 0.161743}, {-0.001325, 0.077515}, {0.008980, -0.012779}, {0.056488, -0.021439}, {0.053925, 0.012779}, {0.013298, 0.014488}, {-0.002779, -0.018738}, {0.016205, -0.033691}, {0.024017, -0.013985}, {-0.000110, -0.000008}, {-0.019470, -0.015228}, {-0.007275, -0.022598}, {-0.004002, 0.013710}},
                                       {{0.082458, -0.126221}, {0.263672, -0.110596}, {0.300781, 0.060486}, {0.165527, 0.168335}, {0.021774, 0.118774}, {-0.004784, 0.010880}, {0.045563, -0.028641}, {0.064880, 0.002218}, {0.028214, 0.020554}, {-0.002726, -0.007568}, {0.008911, -0.034943}, {0.025986, -0.023041}, {0.009003, -0.001179}, {-0.017807, -0.008942}, {-0.012871, -0.023010}, {-0.000627, 0.007317}},
                                       {{0.028854, -0.072266}, {0.210327, -0.142456}, {0.313721, 0.000000}, {0.222412, 0.150635}, {0.059753, 0.149658}, {-0.009422, 0.043030}, {0.028137, -0.026733}, {0.066223, -0.010979}, {0.043030, 0.019791}, {0.002592, 0.004284}, {0.001534, -0.029892}, {0.022736, -0.030121}, {0.016830, -0.005737}, {-0.011833, -0.003235}, {-0.016769, -0.019577}, {-0.000104, -0.000914}},
                                       {{0.003311, -0.018051}, {0.152954, -0.155518}, {0.302490, -0.060852}, {0.267822, 0.112305}, {0.107788, 0.165161}, {-0.001352, 0.079163}, {0.009460, -0.013466}, {0.057953, -0.022003}, {0.054504, 0.012917}, {0.012772, 0.013916}, {-0.002918, -0.019684}, {0.015961, -0.033173}, {0.021744, -0.012657}, {-0.002733, -0.000187}, {-0.017593, -0.013763}, {-0.002934, -0.009109}},
                                       {{0.000471, 0.027573}, {0.098267, -0.150513}, {0.270264, -0.113342}, {0.295654, 0.059448}, {0.159668, 0.162354}, {0.020828, 0.113586}, {-0.004814, 0.010956}, {0.042084, -0.026459}, {0.059967, 0.002050}, {0.026077, 0.018997}, {-0.002378, -0.006607}, {0.007957, -0.031189}, {0.022858, -0.020279}, {0.007561, -0.000989}, {-0.014763, -0.007412}, {-0.008644, -0.015450}},
                                       {{0.012917, 0.058990}, {0.052124, -0.130615}, {0.222412, -0.150635}, {0.302246, 0.000000}, {0.208374, 0.141113}, {0.056091, 0.140503}, {-0.009605, 0.043854}, {0.022385, -0.021271}, {0.057983, -0.009613}, {0.039795, 0.018311}, {0.003874, 0.006401}, {0.001243, -0.024216}, {0.020126, -0.026657}, {0.016830, -0.005737}, {-0.008614, -0.002356}, {-0.015945, -0.018600}},
                                       {{0.032593, 0.074158}, {0.018433, -0.100525}, {0.166260, -0.169067}, {0.287598, -0.057861}, {0.247437, 0.103760}, {0.101013, 0.154785}, {-0.001379, 0.080627}, {0.003632, -0.005169}, {0.048553, -0.018433}, {0.050934, 0.012070}, {0.015099, 0.016449}, {-0.002003, -0.013504}, {0.014458, -0.030060}, {0.023102, -0.013443}, {-0.000278, -0.000019}, {-0.023071, -0.018051}},
                                       {{0.052094, 0.074158}, {-0.001127, -0.065918}, {0.109680, -0.167969}, {0.254639, -0.106750}, {0.271973, 0.054688}, {0.150391, 0.152954}, {0.021194, 0.115540}, {-0.009209, 0.020950}, {0.033417, -0.020996}, {0.056824, 0.001943}, {0.029251, 0.021317}, {-0.000402, -0.001116}, {0.007484, -0.029343}, {0.025146, -0.022308}, {0.008614, -0.001127}, {-0.028214, -0.014168}},
                                       {{0.065796, 0.062561}, {-0.007072, -0.032318}, {0.059753, -0.149658}, {0.208374, -0.141113}, {0.278564, 0.000000}, {0.197998, 0.134155}, {0.056915, 0.142578}, {-0.011856, 0.054138}, {0.015625, -0.014847}, {0.055725, -0.009239}, {0.043488, 0.020004}, {0.006325, 0.010452}, {0.001243, -0.024216}, {0.022736, -0.030121}, {0.016281, -0.005550}, {-0.029953, -0.008186}},
                                       {{0.070557, 0.044342}, {-0.001824, -0.004150}, {0.021759, -0.118652}, {0.155396, -0.158081}, {0.266846, -0.053680}, {0.237427, 0.099548}, {0.102295, 0.156738}, {-0.001536, 0.089905}, {-0.000738, 0.001050}, {0.047455, -0.018005}, {0.054626, 0.012947}, {0.017273, 0.018829}, {-0.002285, -0.015404}, {0.016739, -0.034790}, {0.021225, -0.012352}, {-0.027588, -0.001888}},
                                       {{0.065491, 0.024857}, {0.010895, 0.015511}, {-0.001385, -0.080994}, {0.102539, -0.157104}, {0.238647, -0.100037}, {0.263672, 0.053009}, {0.151978, 0.154541}, {0.022522, 0.122742}, {-0.011383, 0.025909}, {0.033325, -0.020966}, {0.060089, 0.002054}, {0.030533, 0.022247}, {-0.001614, -0.004478}, {0.008896, -0.034882}, {0.022522, -0.019974}, {-0.021362, 0.002796}},
                                       {{0.052155, 0.008652}, {0.026794, 0.025467}, {-0.009422, -0.043030}, {0.056091, -0.140503}, {0.197998, -0.134155}, {0.272949, 0.000000}, {0.199585, 0.135254}, {0.058838, 0.147339}, {-0.012512, 0.057159}, {0.016281, -0.015465}, {0.058289, -0.009666}, {0.043488, 0.020004}, {0.003874, 0.006401}, {0.001534, -0.029892}, {0.020096, -0.026611}, {-0.012413, 0.004230}},
                                       {{0.033630, -0.001150}, {0.041779, 0.026276}, {-0.004444, -0.010117}, {0.020630, -0.112488}, {0.150146, -0.152710}, {0.263916, -0.053101}, {0.238892, 0.100159}, {0.103821, 0.159058}, {-0.001551, 0.090759}, {0.000190, -0.000270}, {0.049072, -0.018631}, {0.053375, 0.012650}, {0.013733, 0.014961}, {-0.003033, -0.020447}, {0.014694, -0.030563}, {-0.002542, 0.001479}},
                                       {{0.013672, -0.003239}, {0.052582, 0.019958}, {0.009674, 0.013763}, {-0.001341, -0.078430}, {0.101257, -0.155151}, {0.238403, -0.099976}, {0.264648, 0.053223}, {0.152344, 0.155029}, {0.022324, 0.121704}, {-0.010582, 0.024078}, {0.034088, -0.021423}, {0.057922, 0.001980}, {0.026474, 0.019287}, {-0.002972, -0.008247}, {0.007813, -0.030640}, {0.006161, -0.005463}},
                                       {{-0.004036, 0.001857}, {0.057190, 0.009483}, {0.028137, 0.026733}, {-0.009605, -0.043854}, {0.056915, -0.142578}, {0.199585, -0.135254}, {0.273193, 0.000000}, {0.198486, 0.134399}, {0.057922, 0.145020}, {-0.012085, 0.055206}, {0.016281, -0.015465}, {0.055725, -0.009239}, {0.039795, 0.018311}, {0.002592, 0.004284}, {0.001358, -0.026459}, {0.011780, -0.015602}},
                                       {{-0.016663, 0.012131}, {0.055145, -0.001885}, {0.046143, 0.029022}, {-0.006004, -0.013664}, {0.021729, -0.118469}, {0.152710, -0.155396}, {0.263916, -0.053070}, {0.236206, 0.099060}, {0.101990, 0.156250}, {-0.001523, 0.089111}, {-0.000270, 0.000384}, {0.046783, -0.017761}, {0.051025, 0.012093}, {0.013321, 0.014511}, {-0.002748, -0.018539}, {0.013039, -0.027115}},
                                       {{-0.022659, 0.024689}, {0.047272, -0.011200}, {0.059692, 0.022659}, {0.006069, 0.008636}, {-0.001492, -0.087280}, {0.103821, -0.159058}, {0.237671, -0.099670}, {0.260742, 0.052460}, {0.149902, 0.152466}, {0.022156, 0.120789}, {-0.011177, 0.025436}, {0.032471, -0.020416}, {0.057678, 0.001972}, {0.027649, 0.020142}, {-0.002975, -0.008263}, {0.009628, -0.037720}},
                                       {{-0.022034, 0.036407}, {0.035492, -0.016327}, {0.066223, 0.010979}, {0.022385, 0.021271}, {-0.011856, -0.054138}, {0.058838, -0.147339}, {0.198486, -0.134399}, {0.268799, 0.000000}, {0.195801, 0.132690}, {0.057922, 0.145020}, {-0.012512, 0.057159}, {0.015625, -0.014847}, {0.057983, -0.009613}, {0.043030, 0.019791}, {0.001443, 0.002384}, {0.002319, -0.045166}},
                                       {{-0.016083, 0.044678}, {0.022339, -0.016266}, {0.064880, -0.002218}, {0.038666, 0.024323}, {-0.010475, -0.023834}, {0.022614, -0.123291}, {0.151367, -0.154053}, {0.259521, -0.052185}, {0.234009, 0.098083}, {0.102600, 0.157227}, {-0.001563, 0.091431}, {-0.000060, 0.000085}, {0.051331, -0.019485}, {0.056396, 0.013367}, {0.010292, 0.011208}, {-0.007080, -0.047729}},
                                       {{-0.007080, 0.047729}, {0.010292, -0.011208}, {0.056396, -0.013367}, {0.051331, 0.019485}, {-0.000060, -0.000085}, {-0.001563, -0.091431}, {0.102600, -0.157227}, {0.234009, -0.098083}, {0.259521, 0.052185}, {0.151367, 0.154053}, {0.022614, 0.123291}, {-0.010475, 0.023834}, {0.038666, -0.024323}, {0.064880, 0.002218}, {0.022339, 0.016266}, {-0.016083, -0.044678}},
                                       {{0.002319, 0.045166}, {0.001443, -0.002384}, {0.043030, -0.019791}, {0.057983, 0.009613}, {0.015625, 0.014847}, {-0.012512, -0.057159}, {0.057922, -0.145020}, {0.195801, -0.132690}, {0.268799, 0.000000}, {0.198486, 0.134399}, {0.058838, 0.147339}, {-0.011856, 0.054138}, {0.022385, -0.021271}, {0.066223, -0.010979}, {0.035492, 0.016327}, {-0.022034, -0.036407}},
                                       {{0.009628, 0.037720}, {-0.002975, 0.008263}, {0.027649, -0.020142}, {0.057678, -0.001972}, {0.032471, 0.020416}, {-0.011177, -0.025436}, {0.022156, -0.120789}, {0.149902, -0.152466}, {0.260742, -0.052460}, {0.237671, 0.099670}, {0.103821, 0.159058}, {-0.001492, 0.087280}, {0.006069, -0.008636}, {0.059692, -0.022659}, {0.047272, 0.011200}, {-0.022659, -0.024689}},
                                       {{0.013039, 0.027115}, {-0.002748, 0.018539}, {0.013321, -0.014511}, {0.051025, -0.012093}, {0.046783, 0.017761}, {-0.000270, -0.000384}, {-0.001523, -0.089111}, {0.101990, -0.156250}, {0.236206, -0.099060}, {0.263916, 0.053070}, {0.152710, 0.155396}, {0.021729, 0.118469}, {-0.006004, 0.013664}, {0.046143, -0.029022}, {0.055145, 0.001885}, {-0.016663, -0.012131}},
                                       {{0.011780, 0.015602}, {0.001358, 0.026459}, {0.002592, -0.004284}, {0.039795, -0.018311}, {0.055725, 0.009239}, {0.016281, 0.015465}, {-0.012085, -0.055206}, {0.057922, -0.145020}, {0.198486, -0.134399}, {0.273193, 0.000000}, {0.199585, 0.135254}, {0.056915, 0.142578}, {-0.009605, 0.043854}, {0.028137, -0.026733}, {0.057190, -0.009483}, {-0.004036, -0.001857}},
                                       {{0.006161, 0.005463}, {0.007813, 0.030640}, {-0.002972, 0.008247}, {0.026474, -0.019287}, {0.057922, -0.001980}, {0.034088, 0.021423}, {-0.010582, -0.024078}, {0.022324, -0.121704}, {0.152344, -0.155029}, {0.264648, -0.053223}, {0.238403, 0.099976}, {0.101257, 0.155151}, {-0.001341, 0.078430}, {0.009674, -0.013763}, {0.052582, -0.019958}, {0.013672, 0.003239}},
                                       {{-0.002542, -0.001479}, {0.014694, 0.030563}, {-0.003033, 0.020447}, {0.013733, -0.014961}, {0.053375, -0.012650}, {0.049072, 0.018631}, {0.000190, 0.000270}, {-0.001551, -0.090759}, {0.103821, -0.159058}, {0.238892, -0.100159}, {0.263916, 0.053101}, {0.150146, 0.152710}, {0.020630, 0.112488}, {-0.004444, 0.010117}, {0.041779, -0.026276}, {0.033630, 0.001150}},
                                       {{-0.012413, -0.004230}, {0.020096, 0.026611}, {0.001534, 0.029892}, {0.003874, -0.006401}, {0.043488, -0.020004}, {0.058289, 0.009666}, {0.016281, 0.015465}, {-0.012512, -0.057159}, {0.058838, -0.147339}, {0.199585, -0.135254}, {0.272949, 0.000000}, {0.197998, 0.134155}, {0.056091, 0.140503}, {-0.009422, 0.043030}, {0.026794, -0.025467}, {0.052155, -0.008652}},
                                       {{-0.021362, -0.002796}, {0.022522, 0.019974}, {0.008896, 0.034882}, {-0.001614, 0.004478}, {0.030533, -0.022247}, {0.060089, -0.002054}, {0.033325, 0.020966}, {-0.011383, -0.025909}, {0.022522, -0.122742}, {0.151978, -0.154541}, {0.263672, -0.053009}, {0.238647, 0.100037}, {0.102539, 0.157104}, {-0.001385, 0.080994}, {0.010895, -0.015511}, {0.065491, -0.024857}},
                                       {{-0.027588, 0.001888}, {0.021225, 0.012352}, {0.016739, 0.034790}, {-0.002285, 0.015404}, {0.017273, -0.018829}, {0.054626, -0.012947}, {0.047455, 0.018005}, {-0.000738, -0.001050}, {-0.001536, -0.089905}, {0.102295, -0.156738}, {0.237427, -0.099548}, {0.266846, 0.053680}, {0.155396, 0.158081}, {0.021759, 0.118652}, {-0.001824, 0.004150}, {0.070557, -0.044342}},
                                       {{-0.029953, 0.008186}, {0.016281, 0.005550}, {0.022736, 0.030121}, {0.001243, 0.024216}, {0.006325, -0.010452}, {0.043488, -0.020004}, {0.055725, 0.009239}, {0.015625, 0.014847}, {-0.011856, -0.054138}, {0.056915, -0.142578}, {0.197998, -0.134155}, {0.278564, 0.000000}, {0.208374, 0.141113}, {0.059753, 0.149658}, {-0.007072, 0.032318}, {0.065796, -0.062561}},
                                       {{-0.028214, 0.014168}, {0.008614, 0.001127}, {0.025146, 0.022308}, {0.007484, 0.029343}, {-0.000402, 0.001116}, {0.029251, -0.021317}, {0.056824, -0.001943}, {0.033417, 0.020996}, {-0.009209, -0.020950}, {0.021194, -0.115540}, {0.150391, -0.152954}, {0.271973, -0.054688}, {0.254639, 0.106750}, {0.109680, 0.167969}, {-0.001127, 0.065918}, {0.052094, -0.074158}},
                                       {{-0.023071, 0.018051}, {-0.000278, 0.000019}, {0.023102, 0.013443}, {0.014458, 0.030060}, {-0.002003, 0.013504}, {0.015099, -0.016449}, {0.050934, -0.012070}, {0.048553, 0.018433}, {0.003632, 0.005169}, {-0.001379, -0.080627}, {0.101013, -0.154785}, {0.247437, -0.103760}, {0.287598, 0.057861}, {0.166260, 0.169067}, {0.018433, 0.100525}, {0.032593, -0.074158}},
                                       {{-0.015945, 0.018600}, {-0.008614, 0.002356}, {0.016830, 0.005737}, {0.020126, 0.026657}, {0.001243, 0.024216}, {0.003874, -0.006401}, {0.039795, -0.018311}, {0.057983, 0.009613}, {0.022385, 0.021271}, {-0.009605, -0.043854}, {0.056091, -0.140503}, {0.208374, -0.141113}, {0.302246, 0.000000}, {0.222412, 0.150635}, {0.052124, 0.130615}, {0.012917, -0.058990}},
                                       {{-0.008644, 0.015450}, {-0.014763, 0.007412}, {0.007561, 0.000989}, {0.022858, 0.020279}, {0.007957, 0.031189}, {-0.002378, 0.006607}, {0.026077, -0.018997}, {0.059967, -0.002050}, {0.042084, 0.026459}, {-0.004814, -0.010956}, {0.020828, -0.113586}, {0.159668, -0.162354}, {0.295654, -0.059448}, {0.270264, 0.113342}, {0.098267, 0.150513}, {0.000471, -0.027573}},
                                       {{-0.002934, 0.009109}, {-0.017593, 0.013763}, {-0.002733, 0.000187}, {0.021744, 0.012657}, {0.015961, 0.033173}, {-0.002918, 0.019684}, {0.012772, -0.013916}, {0.054504, -0.012917}, {0.057953, 0.022003}, {0.009460, 0.013466}, {-0.001352, -0.079163}, {0.107788, -0.165161}, {0.267822, -0.112305}, {0.302490, 0.060852}, {0.152954, 0.155518}, {0.003311, 0.018051}},
                                       {{-0.000104, 0.000914}, {-0.016769, 0.019577}, {-0.011833, 0.003235}, {0.016830, 0.005737}, {0.022736, 0.030121}, {0.001534, 0.029892}, {0.002592, -0.004284}, {0.043030, -0.019791}, {0.066223, 0.010979}, {0.028137, 0.026733}, {-0.009422, -0.043030}, {0.059753, -0.149658}, {0.222412, -0.150635}, {0.313721, 0.000000}, {0.210327, 0.142456}, {0.028854, 0.072266}},
                                       {{-0.000627, -0.007317}, {-0.012871, 0.023010}, {-0.017807, 0.008942}, {0.009003, 0.001179}, {0.025986, 0.023041}, {0.008911, 0.034943}, {-0.002726, 0.007568}, {0.028214, -0.020554}, {0.064880, -0.002218}, {0.045563, 0.028641}, {-0.004784, -0.010880}, {0.021774, -0.118774}, {0.165527, -0.168335}, {0.300781, -0.060486}, {0.263672, 0.110596}, {0.082458, 0.126221}},
                                       {{-0.004002, -0.013710}, {-0.007275, 0.022598}, {-0.019470, 0.015228}, {-0.000110, 0.000008}, {0.024017, 0.013985}, {0.016205, 0.033691}, {-0.002779, 0.018738}, {0.013298, -0.014488}, {0.053925, -0.012779}, {0.056488, 0.021439}, {0.008980, 0.012779}, {-0.001325, -0.077515}, {0.105530, -0.161743}, {0.264648, -0.110962}, {0.306152, 0.061584}, {0.165894, 0.168823}},
                                       {{-0.008804, -0.016800}, {-0.002003, 0.017654}, {-0.016769, 0.019577}, {-0.008614, 0.002356}, {0.016281, 0.005550}, {0.020096, 0.026611}, {0.001358, 0.026459}, {0.001443, -0.002384}, {0.035492, -0.016327}, {0.057190, 0.009483}, {0.026794, 0.025467}, {-0.007072, -0.032318}, {0.052124, -0.130615}, {0.210327, -0.142456}, {0.331299, 0.000000}, {0.276855, 0.187500}},
                                       {{-0.012955, -0.015991}, {0.000723, 0.008438}, {-0.010956, 0.019592}, {-0.014740, 0.007401}, {0.003372, 0.000441}, {0.017624, 0.015625}, {0.007320, 0.028702}, {-0.004910, 0.013634}, {0.013405, -0.009766}, {0.046173, -0.001579}, {0.043091, 0.027084}, {0.004395, 0.010002}, {0.014381, -0.078430}, {0.145630, -0.148193}, {0.335449, -0.067444}, {0.407715, 0.170898}},
                                       {{-0.014175, -0.011734}, {-0.001096, -0.003754}, {-0.004360, 0.013542}, {-0.017273, 0.013519}, {-0.012924, 0.000885}, {0.006893, 0.004013}, {0.011917, 0.024780}, {-0.004532, 0.030563}, {-0.007465, 0.008133}, {0.024551, -0.005817}, {0.052734, 0.020020}, {0.030334, 0.043152}, {-0.000207, -0.012100}, {0.081299, -0.124512}, {0.316650, -0.132690}, {0.546875, 0.109924}},
                                       {{-0.010483, -0.005630}, {-0.008804, -0.016800}, {-0.000104, 0.000914}, {-0.015945, 0.018600}, {-0.029953, 0.008186}, {-0.012413, -0.004230}, {0.011780, 0.015602}, {0.002319, 0.045166}, {-0.022034, 0.036407}, {-0.004036, 0.001857}, {0.052155, 0.008652}, {0.065796, 0.062561}, {0.012917, 0.058990}, {0.028854, -0.072266}, {0.276855, -0.187500}, {0.678223, 0.000000}},
                                       {{-0.000733, -0.000222}, {-0.022751, -0.028076}, {-0.001487, -0.017349}, {-0.011505, 0.020569}, {-0.044647, 0.022415}, {-0.038818, -0.005077}, {0.004128, 0.003660}, {0.013939, 0.054626}, {-0.025940, 0.072021}, {-0.033844, 0.024658}, {0.040039, -0.001369}, {0.104553, 0.065735}, {0.054565, 0.124207}, {-0.000592, 0.003229}, {0.220581, -0.224487}, {0.785645, -0.158081}}};

static constexpr uint32_t N_TONES_PER_PRB = 12;
static constexpr uint32_t N_GOLD_ENTRY_BITS = descrambling::BITS_PROCESSED_PER_LUT_ENTRY;
static constexpr uint32_t N_DATA_RE_PRB = 8;
static constexpr uint32_t SYM_PER_SLOT = 14;
static constexpr uint32_t N_TA_EST_SC = N_TONES_PER_PRB-N_DATA_RE_PRB-1;
static constexpr uint32_t MU_0_HZ = 15000;
static constexpr float RAD_TO_USEC = 1000000.0/(2.0*M_PI);
static constexpr float RSQRT2 = 0.7071067811865476; // 1/sqrt(2)
static constexpr float MAX_DB   = 99.9; // Maximum reportable SINR/RSSI/RSRP in dB
static constexpr float MIN_DB   =-99.9; // Minimum reportable SINR/RSSI/RSRP in dB
static constexpr float MIN_DB_LIN = 1.0232929922807537e-10; // pow(10,MIN_DB/10)
static constexpr float LP_FILT_BIAS =  3.0/1.75; // Bias correction factor from low-pass filtering

static __global__ void
pucchF2RxKernel(pucchF2RxDynDescr_t* pDynDescr)
{
    auto                      cta  = cg::this_thread_block();
    cg::thread_block_tile<32> tile = cg::tiled_partition<32>(cta);
    uint32_t                  uci_num  = blockIdx.x;

    // UCI group local to this CTA
    auto local_group = 0;

    // UCI data for this group
    auto uci_data = &pDynDescr->uciPrms[uci_num];

    // cell idx
    int16_t cellIdx  = uci_data->cellIdx;
    int16_t numRxAnt = pDynDescr->pCellPrms[cellIdx].nRxAnt;

    tensor_ref<const __half2> tDataRx(pDynDescr->pCellPrms[cellIdx].tDataRx.pAddr, pDynDescr->pCellPrms[cellIdx].tDataRx.strides);

    // F2 uses 2 data and 1 DMRS for every 3 PRBs, so shared memory for these types can be reduced a bit
    __shared__ __half2 y_dmrs[F2_UCIS_PER_BLOCK * F2_MAX_SYMS * N_TONES_PER_PRB / 3 * F2_MAX_PRBS * F2_MAX_RX_ANTENNA];
    __shared__ __half2 ch_est_dmrs[F2_UCIS_PER_BLOCK * F2_MAX_SYMS * N_TONES_PER_PRB / 3 * F2_MAX_PRBS * F2_MAX_RX_ANTENNA];
    __shared__ __half2 y_data[F2_UCIS_PER_BLOCK * F2_MAX_SYMS * N_TONES_PER_PRB * 2 / 3 * F2_MAX_PRBS * F2_MAX_RX_ANTENNA];
    __shared__ __half2 dmrs_chest_full[F2_UCIS_PER_BLOCK * F2_MAX_SYMS * N_TONES_PER_PRB * F2_MAX_PRBS * F2_MAX_RX_ANTENNA];
    __shared__ __half2 x_dmrs[F2_UCIS_PER_BLOCK * F2_MAX_PRBS * 4 * F2_MAX_SYMS];
    __shared__ __half2 z[F2_UCIS_PER_BLOCK * F2_MAX_SYMS * F2_MAX_PRBS * N_TONES_PER_PRB]; // 10752
    __shared__ __half2 sc_crr_reduc[F2_CG_SIZE / 32];
    __shared__ float   rx_energy_reduc[F2_CG_SIZE / 32];
    __shared__ float   rssi_linear_reduc[F2_CG_SIZE / 32];
    __shared__ float   r_tilde_reduc[F2_CG_SIZE / 32];
    __shared__ __half2 scrm_llr[F2_UCIS_PER_BLOCK * F2_MAX_SYMS * F2_MAX_PRBS * 8]; // 10752

    __half2* uci_y_dmrs           = &y_dmrs[local_group * F2_MAX_SYMS * N_TONES_PER_PRB / 3 * F2_MAX_PRBS * F2_MAX_RX_ANTENNA];
    __half2* uci_ch_est_dmrs_s    = &ch_est_dmrs[local_group * F2_MAX_SYMS * N_TONES_PER_PRB / 3 * F2_MAX_PRBS * F2_MAX_RX_ANTENNA];
    __half2* uci_data_s           = &y_data[local_group * F2_MAX_SYMS * N_TONES_PER_PRB * 2 / 3 * F2_MAX_PRBS * F2_MAX_RX_ANTENNA];
    __half2* uci_dmrs_ch_est_full = &dmrs_chest_full[local_group * F2_MAX_SYMS * N_TONES_PER_PRB * F2_MAX_PRBS * F2_MAX_RX_ANTENNA];
    __half2* uci_x_dmrs           = &x_dmrs[local_group * F2_MAX_PRBS * 4 * F2_MAX_SYMS];
    __half2* uci_z                = &z[0];
    __half2* uci_scrmLLR          = &scrm_llr[local_group * F2_MAX_SYMS * F2_MAX_PRBS * 8];

    int tot_scs = N_TONES_PER_PRB * uci_data->prbSize;
    int lane    = cta.thread_rank();

    __half2       tmp;
    float2        tempf;
    constexpr int prbBlockSize = 4;
    constexpr int scsBlockSize = prbBlockSize * N_TONES_PER_PRB / 3; // 1 of every 3 symbols is DMRS

    // Compute x_dmrs in the MATLAB code by using the scrambling sequences
    int round         = (uci_data->E_seg1 + N_GOLD_ENTRY_BITS - 1) / N_GOLD_ENTRY_BITS;
    uint16_t bwpStart = uci_data->bwpStart;
    uint16_t startCrb = uci_data->startPrb + bwpStart;
    int16_t  slotNum  = pDynDescr->pCellPrms[cellIdx].slotNum;
    uint8_t  startSym = uci_data->startSym;

    int cInit    = uci_data->rnti * 32768 + uci_data->dataScramblingId;
    for(int i = lane; i < round; i += F2_CG_SIZE)
    {
        uint32_t g                 = descrambling::gold32n(cInit, N_GOLD_ENTRY_BITS*i);
        uci_data->randomSeqScrm[i] = g;
    }

    int DmrsScramblingId = int(uci_data->DmrsScramblingId);
    // Models equation from TS38.211 6.4.1.2.1.2 for cIinit
    cInit                = (131072 * (SYM_PER_SLOT * slotNum + startSym + 1) * (2 * DmrsScramblingId + 1) + 2 * DmrsScramblingId) % 0x80000000;
    uint32_t gold_seq;
    // Initializing to a sufficiently small number to ensure new gold_seq is generated on the first pass
    int offset = -1*static_cast<int>(N_GOLD_ENTRY_BITS); 
    for(int idx = lane; idx < uci_data->prbSize * 4; idx += F2_CG_SIZE)
    {
        int gold_idx = 2*idx + 8*startCrb;
        if( N_GOLD_ENTRY_BITS <= (gold_idx - offset))
        {
            offset = gold_idx;
            gold_seq = descrambling::gold32n(cInit, offset);
        }
        uint32_t bitPos = gold_idx - offset;
        uci_x_dmrs[idx] = {RSQRT2 * (1 - 2 * static_cast<int>(((gold_seq >> bitPos) & 1))), 
                           RSQRT2 * (1 - 2 * static_cast<int>(((gold_seq >> (bitPos+1)) & 1)))};
        
    }

    if(uci_data->nSym > 1)
    {
        offset = -1*static_cast<int>(N_GOLD_ENTRY_BITS);
        uint16_t startSecondHop = 4*startCrb;
        cInit    = (131072 * (SYM_PER_SLOT * slotNum + startSym + 2) * (2 * DmrsScramblingId + 1) + 2 * DmrsScramblingId) % 0x80000000;
        if(uci_data->freqHopFlag)
        {
            startSecondHop = 4*(uci_data->secondHopPrb + bwpStart);
        }
        for(int idx = lane; idx < uci_data->prbSize * 4; idx += F2_CG_SIZE)
        {
            int gold_idx = 2*(idx + startSecondHop);
            if( N_GOLD_ENTRY_BITS <= (gold_idx - offset))
            {
                offset = gold_idx;
                gold_seq = descrambling::gold32n(cInit, offset);
            }
            uint32_t bitPos = gold_idx - offset;
            uci_x_dmrs[uci_data->prbSize * 4 + idx] = {RSQRT2 * (1 - 2 * static_cast<int>(((gold_seq >> bitPos) & 1))), 
                                                       RSQRT2 * (1 - 2 * static_cast<int>(((gold_seq >> (bitPos+1)) & 1)))};
        }
    }
    cta.sync();

    // Pull in all values needed to construct Y_pucch from the MATLAB code. Because of the relatively low amount of data to fetch, and the
    // layout of this data, the access patterns are not ideal. We rely heavily on the L2 cache to make this fast, but this can be optimized
    // if it's a hot spot. Right now this is < 10% of the total kernel time. We also accumulate RSSI as we go instead of afterwards to avoid
    // an extra loop. As mentioned above, DMRS is only present in the second PRB, so we use a conditional on the PRB number to decide if it
    // goes in the DMRS or data shared memory
    //
    // Unlike the MATLAB code, data and DMRS are separated here so we can access the data elements with a contiguous stride later
    int data_idx = 0;
    int dmrs_idx = 0;
    int startSc = startCrb * CUPHY_N_TONES_PER_PRB;

    float rssi_linear_temp = 0;

    if(uci_data->freqHopFlag && uci_data->nSym > 1)
    {
        for(int prbOffset = 0; prbOffset < tot_scs; prbOffset++)
        {
            for(int idx = lane; idx < uci_data->nSym * numRxAnt; idx += F2_CG_SIZE)
            { // This usually won't do anything unless the number of antennas is high
                int a = idx % numRxAnt;
                if(idx < numRxAnt)
                {
                    tmp = tDataRx(startSc + prbOffset, startSym, a);
                    tempf = __half22float2(tmp);
                    rssi_linear_temp += tempf.x*tempf.x + tempf.y*tempf.y;

                    if((prbOffset % 3) == 1)
                    {
                        uci_y_dmrs[dmrs_idx * uci_data->nSym * numRxAnt + 0 * numRxAnt + a]        = tmp;
                        uci_ch_est_dmrs_s[dmrs_idx * uci_data->nSym * numRxAnt + 0 * numRxAnt + a] = complex_conjmul(tmp, uci_x_dmrs[dmrs_idx]);
                        dmrs_idx++;
                    }
                    else
                    {
                        uci_data_s[data_idx * uci_data->nSym * numRxAnt + 0 * numRxAnt + a] = tmp;
                        data_idx++;
                    }
                }
            }
        }

        data_idx = 0;
        dmrs_idx = 0;
        // Second symbol
        int secondHopStartSc = (uci_data->secondHopPrb + bwpStart) * CUPHY_N_TONES_PER_PRB;
        for(int prbOffset = 0; prbOffset < tot_scs; prbOffset++)
        {
            for(int idx = lane; idx < uci_data->nSym * numRxAnt; idx += F2_CG_SIZE)
            { // This usually won't do anything unless the number of antennas is high
                int a = idx % numRxAnt;
                if(idx < numRxAnt)
                {
                    tmp = tDataRx(secondHopStartSc + prbOffset, startSym + 1, a);
                    tempf = __half22float2(tmp);
                    rssi_linear_temp += tempf.x*tempf.x + tempf.y*tempf.y;

                    if((prbOffset % 3) == 1)
                    {
                        uci_y_dmrs[dmrs_idx * uci_data->nSym * numRxAnt + 1 * numRxAnt + a]        = tmp;
                        uci_ch_est_dmrs_s[dmrs_idx * uci_data->nSym * numRxAnt + 1 * numRxAnt + a] = complex_conjmul(tmp, uci_x_dmrs[uci_data->prbSize * 4 + dmrs_idx]);
                        dmrs_idx++;
                    }
                    else
                    {
                        uci_data_s[data_idx * uci_data->nSym * numRxAnt + 1 * numRxAnt + a] = tmp;
                        data_idx++;
                    }
                }
            }
        }
    }
    else
    {
        for(int prbOffset = 0; prbOffset < tot_scs; prbOffset++)
        {
            for(int idx = lane; idx < uci_data->nSym * numRxAnt; idx += F2_CG_SIZE)
            { // This usually won't do anything unless the number of antennas is high
                int sym = idx / numRxAnt;
                int a   = idx % numRxAnt;
                if(sym < uci_data->nSym)
                {
                    tmp = tDataRx(startSc + prbOffset, startSym + sym, a);
                    tempf = __half22float2(tmp);
                    rssi_linear_temp += tempf.x*tempf.x + tempf.y*tempf.y;

                    if((prbOffset % 3) == 1)
                    {
                        uci_y_dmrs[dmrs_idx * uci_data->nSym * numRxAnt + sym * numRxAnt + a]        = tmp;
                        uci_ch_est_dmrs_s[dmrs_idx * uci_data->nSym * numRxAnt + sym * numRxAnt + a] = complex_conjmul(tmp, uci_x_dmrs[sym * uci_data->prbSize * 4 + dmrs_idx]);
                        dmrs_idx++;
                    }
                    else
                    {
                        uci_data_s[data_idx * uci_data->nSym * numRxAnt + sym * numRxAnt + a] = tmp;
                        data_idx++;
                    }
                }
            }
        }
    }
    cta.sync();

    rssi_linear_temp = cg::reduce(tile, rssi_linear_temp, cg::plus<float>());

    // At this point the partial channel estimates have been computed. Compute the full channel estimates by multiplying by the W matrix
    int num_dmrs = tot_scs / 3;

    // Correlate and sum adjacent subcarriers for TA estimation
    __half2 sum_sc_corr = {0.0,0.0};
    for(int k = lane; k<N_TA_EST_SC*uci_data->nSym*numRxAnt; k+=F2_CG_SIZE)
    {
        int sc = k / (uci_data->nSym*numRxAnt);
        int sym = (k / numRxAnt) % uci_data->nSym;
        int a = k % numRxAnt;
        sum_sc_corr += complex_conjmul(uci_ch_est_dmrs_s[numRxAnt * uci_data->nSym * sc + sym * numRxAnt + a],uci_ch_est_dmrs_s[numRxAnt * uci_data->nSym * (sc+1) + sym * numRxAnt + a]);
    }
 
    // Similar to PF3, if the PRB size can be multiplied by W1-W3, we simply do a single GEMM. However, if the number of PRBs is larger,
    // we multiply by W4 in batches. If the final batch doesn't divide evenly into the columns of W4 (16), we move to the last batch
    // that fits evenly
    if(uci_data->prbSize < 4)
    {
        __half2* Ws[3] = {&d_W1[0][0], &d_W2[0][0], &d_W3[0][0]};
        __half2* W     = Ws[uci_data->prbSize - 1];

        for(int a = 0; a < numRxAnt; a++)
        {
            for(int sym = 0; sym < uci_data->nSym; sym++)
            {
                __half2 accum = {0.0, 0.0};
                if(lane < tot_scs)
                {
                    for(int sc = 0; sc < 4 * uci_data->prbSize; sc++)
                    {
                        accum += complex_mul(W[lane * 4 * uci_data->prbSize + sc], uci_ch_est_dmrs_s[numRxAnt * uci_data->nSym * sc + sym * numRxAnt + a]);
                    }
                }

                cta.sync();

                if(lane < tot_scs)
                {
                    uci_dmrs_ch_est_full[numRxAnt * uci_data->nSym * lane + sym * numRxAnt + a] = accum;
                }

                cta.sync();
            }
        }
    }
    else
    {
        int first_pass = num_dmrs / scsBlockSize;
        int block;

        // Do first set of multiplies on all full blocks
        for(int a = 0; a < numRxAnt; a++)
        {
            for(int sym = 0; sym < uci_data->nSym; sym++)
            {
                // Iterate over all the blocks of 4
                for(block = 0; block < first_pass; block++)
                {
                    __half2 accum = {0.0, 0.0};
                    if(lane < W4_ROWS)
                    {
                        for(int sc = 0; sc < W4_COLS; sc++)
                        { // Always 16 columns in W4 case
                            accum += complex_mul(d_W4[lane][sc], uci_ch_est_dmrs_s[numRxAnt * uci_data->nSym * ((block * scsBlockSize) + sc) + sym * numRxAnt + a]);
                        }
                    }

                    cta.sync();

                    if(lane < W4_ROWS)
                    { // Always 48 rows in W4
                        // scsBlockSize is relative to DMRS PRBs, so we need to multiply by 3 to get it back to total PRBs
                        uci_dmrs_ch_est_full[numRxAnt * uci_data->nSym * ((block * scsBlockSize * 3) + lane) + sym * numRxAnt + a] = accum;
                    }
                }
            }
        }

        cta.sync();

        for(int a = 0; a < numRxAnt; a++)
        {
            for(int sym = 0; sym < uci_data->nSym; sym++)
            {
                // Now if we have a partial block, do that one here.
                if((block * scsBlockSize < num_dmrs))
                {
                    __half2 accum = {0.0, 0.0};

                    int start = block * scsBlockSize - (scsBlockSize - (num_dmrs - block * scsBlockSize));
                    if(lane < W4_ROWS)
                    {
                        for(int sc = 0; sc < W4_COLS; sc++)
                        {
                            accum += complex_mul(d_W4[lane][sc], uci_ch_est_dmrs_s[numRxAnt * uci_data->nSym * (start + sc) + sym * numRxAnt + a]);
                        }
                    }

                    cta.sync();

                    if(lane < 48)
                    { // Always 48 rows in W4
                        // "start" is the offset relative to dmrs rows, so we multiply that by 3 to get back to total PRB rows
                        uci_dmrs_ch_est_full[numRxAnt * uci_data->nSym * (start * 3 + lane) + sym * numRxAnt + a] = accum;
                    }

                    cta.sync();
                }
            }
        }
    }

    cta.sync();

    // Calculate RE energy to compare against DTX threshold. A full CTA reduction is performed to compute
    // the total power
    float rx_energy = 0.0;
    float r_tilde   = 0.0;
    int   num_samps = tot_scs * uci_data->nSym * numRxAnt;
    for(int tid = lane; tid < num_samps; tid += F2_CG_SIZE)
    {
        rx_energy += __half2float(uci_dmrs_ch_est_full[tid].x * uci_dmrs_ch_est_full[tid].x + uci_dmrs_ch_est_full[tid].y * uci_dmrs_ch_est_full[tid].y);
    }

    int dmrs_samps = num_dmrs * uci_data->nSym * numRxAnt;
    for(int tid = lane; tid < dmrs_samps; tid += F2_CG_SIZE)
    {
        int prb    = tid / (uci_data->nSym * numRxAnt);
        int prbidx = tid % (uci_data->nSym * numRxAnt);
        int sym    = prbidx / numRxAnt;
        int a      = prbidx % numRxAnt;

        auto tmp = uci_y_dmrs[prb * uci_data->nSym * numRxAnt + sym * numRxAnt + a] -
                   complex_mul(uci_x_dmrs[sym * uci_data->prbSize * 4 + prb], uci_dmrs_ch_est_full[(1 + prb * 3) * numRxAnt * uci_data->nSym + sym * numRxAnt + a]);
        r_tilde += static_cast<float>(tmp.x * tmp.x + tmp.y * tmp.y);
    }

    cta.sync();

    sum_sc_corr = cg::reduce(tile, sum_sc_corr, cg::plus<__half2>());
    rx_energy = cg::reduce(tile, rx_energy, cg::plus<float>()) / (float)num_samps;
    r_tilde   = cg::reduce(tile, r_tilde, cg::plus<float>()) / (float)dmrs_samps;
    if(tile.thread_rank() == 0)
    {
        sc_crr_reduc[tile.meta_group_rank()]    = sum_sc_corr;
        rx_energy_reduc[tile.meta_group_rank()] = rx_energy;
        r_tilde_reduc[tile.meta_group_rank()]   = r_tilde;
        rssi_linear_reduc[tile.meta_group_rank()] = rssi_linear_temp;
    }

    cta.sync();

    sum_sc_corr      = {0.0, 0.0};
    rx_energy        = 0.0;
    rssi_linear_temp = 0.0;
    r_tilde          = 0.0;
    float sinr_dB = MIN_DB;

    if(cta.thread_rank() == 0)
    {
        for(int i = 0; i < F2_CG_SIZE / 32; i++)
        {
            sum_sc_corr += sc_crr_reduc[i];
            rx_energy += rx_energy_reduc[i];
            r_tilde += r_tilde_reduc[i];
            rssi_linear_temp += rssi_linear_reduc[i];
        }
        pDynDescr->pNoiseVar[uci_num]  = r_tilde;

        r_tilde_reduc[0] = MIN_DB;
        float rsrp_dB    = MIN_DB;
        float rssi_dB    = MIN_DB;
        float taEstMicroSec = 0.0;

        if(rx_energy > MIN_DB_LIN)
        {
            r_tilde *= LP_FILT_BIAS;
            if (r_tilde > MIN_DB_LIN)
            {
                r_tilde_reduc[0]   = 10 * log10(r_tilde);
            }

            // TA report
            float  angle = atan2f(__half2float(sum_sc_corr.y),__half2float(sum_sc_corr.x));
            uint32_t scs = MU_0_HZ<<pDynDescr->pCellPrms[cellIdx].mu;
            taEstMicroSec = RAD_TO_USEC*angle/(3.0*float(scs));

            rsrp_dB = 10 * log10(rx_energy); // value in dBm
            rssi_dB = 10 * log10(rssi_linear_temp/static_cast<float>(uci_data->nSym));
            sinr_dB = rsrp_dB - r_tilde_reduc[0];        
        }
        r_tilde_reduc[1]   = r_tilde; // Store linear version for other threads later

        // SINR report
        pDynDescr->pSinr[uci_num] = std::min({MAX_DB, sinr_dB});

        // RSRP report
        pDynDescr->pRsrp[uci_num] = std::min({MAX_DB, rsrp_dB});

        // RSSI report
        pDynDescr->pRssi[uci_num] = std::min({MAX_DB, rssi_dB});
        
        // Interference level report 
        pDynDescr->pInterf[uci_num] = std::min({MAX_DB, r_tilde_reduc[0]}); // value in dB

        // TA report
        pDynDescr->pTaEst[uci_num]  = taEstMicroSec;
    }

    cta.sync();

    if(cta.thread_rank() == 0)
    {
        if(sinr_dB < uci_data->DTXthreshold)
        {
            pDynDescr->pDTXflags[uci_num] = 1;
        }
    }

    // Compute z from MATLAB using only the data PRBs. The indexing is a little strange here because uci_data_s is the
    // compacted form having only data PRBs, while uci_dmrs_ch_est_full is the total size of all PRBs. We use dmrs_idx to skip
    // to only the data PRBs in that array.
    int data_scs = (tot_scs * 2) / 3;
    for(int tid = lane; tid < data_scs * uci_data->nSym; tid += F2_CG_SIZE)
    {
        __half2 accum = {0, 0};

        int sc  = tid / uci_data->nSym;
        int sym = tid % uci_data->nSym;

        // Create a sequence for data PRBs: 0     2     3     5     6     8     9    11    12...
        int dmrs_idx = sc / 2 * 3 + (sc % 2) * 2;

        for(int a = 0; a < numRxAnt; a++)
        {
            accum += complex_conjmul(uci_data_s[numRxAnt * uci_data->nSym * sc + sym * numRxAnt + a],
                                       uci_dmrs_ch_est_full[numRxAnt * uci_data->nSym * dmrs_idx + sym * numRxAnt + a]);
        }
        uci_z[sym * data_scs + sc] = accum;
    }

    cta.sync();

    // Compute LLRs
    for(int i = lane; i < uci_data->prbSize * uci_data->nSym * 8; i += F2_CG_SIZE)
    {
        uci_scrmLLR[i].x = __float2half(2.0 * __half2float(uci_z[i].x) / r_tilde_reduc[1]);
        uci_scrmLLR[i].y = __float2half(2.0 * __half2float(uci_z[i].y) / r_tilde_reduc[1]);
    }

    cta.sync();

    // Write output values to global for next kernel
    for(int i = lane; i < uci_data->E_seg1; i += F2_CG_SIZE)
    {
        int      idx                        = i / 32;
        uint32_t off                        = i % 32;
        __half*  scrm                       = reinterpret_cast<__half*>(&uci_scrmLLR[0]) + i;
        pDynDescr->pDescramLLRaddrs[uci_num][i] = __hmul((__half)(1 - 2 * ((uci_data->randomSeqScrm[idx] & (1U << off)) > 0)), *scrm);
    }

    if(threadIdx.x == 0)
    {
        pDynDescr->pDTXflags[uci_num] = 0;
    }
}

} // namespace pucch_F2

using namespace pucch_F2;

/** 
 * Loads the constant tables into constant memory
 */
 void pucchF2Rx::InitConstantMem(cudaStream_t strm)
 {
  CUDA_CHECK(cudaMemcpyToSymbolAsync(d_W1, W1, sizeof(W1), 0, cudaMemcpyHostToDevice, strm));
  CUDA_CHECK(cudaMemcpyToSymbolAsync(d_W2, W2, sizeof(W2), 0, cudaMemcpyHostToDevice, strm));
  CUDA_CHECK(cudaMemcpyToSymbolAsync(d_W3, W3, sizeof(W3), 0, cudaMemcpyHostToDevice, strm));
  CUDA_CHECK(cudaMemcpyToSymbolAsync(d_W4, W4, sizeof(W4), 0, cudaMemcpyHostToDevice, strm));
 }

pucchF2Rx::pucchF2Rx(cudaStream_t strm)
{
   {
      std::lock_guard<std::mutex> lockGaurdConstMemInit(m_mutexConstMemInit);
      if(~isConstMemInited)
      {
         isConstMemInited = true;
         InitConstantMem(strm);
      }
   }
}

void pucchF2Rx::kernelSelect(uint16_t                   nUcis,
                             pucchF2RxDynDescr_t*       pCpuDynDesc,
                             cuphyPucchF2RxLaunchCfg_t* pLaunchCfg)
{
  // kernel (only one kernel option for now)
  void* kernelFunc = reinterpret_cast<void*>(pucchF2RxKernel);
  CUDA_CHECK(cudaGetFuncBySymbol(&pLaunchCfg->kernelNodeParamsDriver.func, kernelFunc));

  // launch geometry (can change!)
  dim3 gridDim(nUcis);
  dim3 blockDim(F2_CG_SIZE);

  // populate kernel parameters
  CUDA_KERNEL_NODE_PARAMS& kernelNodeParamsDriver = pLaunchCfg->kernelNodeParamsDriver;

  kernelNodeParamsDriver.blockDimX = blockDim.x;
  kernelNodeParamsDriver.blockDimY = blockDim.y;
  kernelNodeParamsDriver.blockDimZ = blockDim.z;

  kernelNodeParamsDriver.gridDimX = gridDim.x;
  kernelNodeParamsDriver.gridDimY = gridDim.y;
  kernelNodeParamsDriver.gridDimZ = gridDim.z;

  kernelNodeParamsDriver.extra    = nullptr;
  kernelNodeParamsDriver.sharedMemBytes = 0;
}

void pucchF2Rx::setup(cuphyTensorPrm_t*          pDataRx, // input slot buffer
                      __half**                   pDescramLLRaddrs,
                      uint8_t*                   pDTXflags,
                      float*                     pSinr,
                      float*                     pRssi,
                      float*                     pRsrp,
                      float*                     pInterf,
                      float*                     pNoiseVar,
                      float*                     pTaEst,
                      uint16_t                   nCells, // number of cells
                      uint16_t                   nF2Ucis,
                      cuphyPucchUciPrm_t*        pF2UciPrms,
                      cuphyPucchCellPrm_t*       pCmnCellPrms, // number of antennas, slot number, hopping idx and input slot buffer
                      bool                       enableCpuToGpuDescrAsyncCpy,
                      pucchF2RxDynDescr_t*       pCpuDynDesc, // pointer to descriptor in cpu
                      void*                      pGpuDynDesc, // pointer to descriptor in gpu
                      cuphyPucchF2RxLaunchCfg_t* pLaunchCfg,  // pointer to launch configuration
                      cudaStream_t               strm)                      // stream to perform copy
{
    pCpuDynDesc->pCellPrms = pCmnCellPrms;
    if(CUPHY_PUCCH_F2_MAX_UCI < nF2Ucis)
    {
        NVLOGE_FMT(NVLOG_PUCCH, AERIAL_CUPHY_EVENT, "Number of PF2 UCIs {} is more than max allocation ({}).  Dropping additional UCIs.",nF2Ucis,CUPHY_PUCCH_F2_MAX_UCI);
        nF2Ucis = CUPHY_PUCCH_F2_MAX_UCI;
    }
    pCpuDynDesc->numUcis   = nF2Ucis;

    for(int uciIdx = 0; uciIdx < nF2Ucis; ++uciIdx)
    {
        uint16_t cellIdx                              = pF2UciPrms[uciIdx].cellPrmDynIdx;
        pCpuDynDesc->uciPrms[uciIdx].freqHopFlag      = pF2UciPrms[uciIdx].freqHopFlag;
        uint8_t  nSym                                 = pF2UciPrms[uciIdx].nSym;
        pCpuDynDesc->uciPrms[uciIdx].nSym             = nSym;
        uint8_t  prbSize                              = pF2UciPrms[uciIdx].prbSize;
        pCpuDynDesc->uciPrms[uciIdx].prbSize          = prbSize;
        pCpuDynDesc->uciPrms[uciIdx].startSym         = pF2UciPrms[uciIdx].startSym;
        pCpuDynDesc->uciPrms[uciIdx].bwpStart         = pF2UciPrms[uciIdx].bwpStart;
        pCpuDynDesc->uciPrms[uciIdx].startPrb         = pF2UciPrms[uciIdx].startPrb;
        pCpuDynDesc->uciPrms[uciIdx].secondHopPrb     = pF2UciPrms[uciIdx].secondHopPrb;
        pCpuDynDesc->uciPrms[uciIdx].noiseVar         = 0.01;
        pCpuDynDesc->uciPrms[uciIdx].uciOutputIdx     = pF2UciPrms[uciIdx].uciOutputIdx;
        pCpuDynDesc->uciPrms[uciIdx].rnti             = pF2UciPrms[uciIdx].rnti;
        pCpuDynDesc->uciPrms[uciIdx].dataScramblingId = pF2UciPrms[uciIdx].dataScramblingId;
        pCpuDynDesc->uciPrms[uciIdx].DmrsScramblingId = pF2UciPrms[uciIdx].DmrsScramblingId;
        uint16_t E_seg1                               = nSym * prbSize * 16;
        pCpuDynDesc->uciPrms[uciIdx].E_seg1           = E_seg1;

        float extDTXthreshold = pF2UciPrms[uciIdx].DTXthreshold;

        if(extDTXthreshold == CUPHY_DEFAULT_EXT_DTX_THRESHOLD)
        {
            pCpuDynDesc->uciPrms[uciIdx].DTXthreshold = defF2DTXthreshold;
        }
        else
        {
            pCpuDynDesc->uciPrms[uciIdx].DTXthreshold = extDTXthreshold;
        }

        // cell index
        pCpuDynDesc->uciPrms[uciIdx].cellIdx = cellIdx;
    }

    for (uint16_t i = 0; i < nCells; i++)
    {
        copyTensorPrm2Info(pDataRx[i], pCpuDynDesc->pCellPrms[i].tDataRx);
    }
    for(int uciIdx = 0; uciIdx < nF2Ucis; ++uciIdx)
    {
        pCpuDynDesc->pDescramLLRaddrs[uciIdx] = pDescramLLRaddrs[uciIdx];
    }
    pCpuDynDesc->pDTXflags = pDTXflags;
    pCpuDynDesc->pSinr     = pSinr;
    pCpuDynDesc->pRssi     = pRssi;
    pCpuDynDesc->pRsrp     = pRsrp;
    pCpuDynDesc->pInterf   = pInterf;
    pCpuDynDesc->pNoiseVar = pNoiseVar;
    pCpuDynDesc->pTaEst    = pTaEst;

    pucchF2KernelArgs_t& kernelArgs = m_kernelArgs;
    kernelArgs.pDynDescr            = reinterpret_cast<pucchF2RxDynDescr_t*>(pGpuDynDesc);

    // Optional descriptor copy to GPU memory
    if(enableCpuToGpuDescrAsyncCpy)
    {
      cudaMemcpyAsync(pGpuDynDesc, pCpuDynDesc, sizeof(pucchF2RxDynDescr_t), cudaMemcpyHostToDevice, strm);
    }

    // select kernel (includes launch geometry). Populate launchCfg.
    kernelSelect(nF2Ucis, pCpuDynDesc, pLaunchCfg);
    pLaunchCfg->kernelArgs[0]                       = &m_kernelArgs.pDynDescr;
    pLaunchCfg->kernelNodeParamsDriver.kernelParams = &(pLaunchCfg->kernelArgs[0]);
}

void pucchF2Rx::getDescrInfo(size_t& dynDescrSizeBytes, size_t& dynDescrAlignBytes)
{
   dynDescrSizeBytes  = sizeof(pucchF2RxDynDescr_t);
   dynDescrAlignBytes = alignof(pucchF2RxDynDescr_t);
}