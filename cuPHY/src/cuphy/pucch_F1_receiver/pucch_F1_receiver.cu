/*
 * Copyright (c) 2021-2023, NVIDIA CORPORATION & AFFILIATES.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */

#include "pucch_F1_receiver.hpp"
#include "descrambling.cuh"
#include <cooperative_groups.h>
#include <cooperative_groups/reduce.h>
#include <functional>
#include "cuComplex.h"
#include "cuda_fp16.h"
#include "math_utils.cuh"
#include "cuphy.hpp"
#include <cmath>

namespace cg = cooperative_groups;

bool pucchF1Rx::isConstMemInited = false;
std::mutex pucchF1Rx::m_mutexConstMemInit;

// #define ENABLE_DEBUG_F1 

namespace pucch_F1
{
template <typename TElem>
struct tensor_ref
{
    TElem*         addr;
    const int32_t* strides;

    CUDA_BOTH
    tensor_ref(void* pAddr, const int32_t* pStrides) :
        addr(static_cast<TElem*>(pAddr)),
        strides(pStrides)
    {
    }
    CUDA_BOTH long offset(int i0) const
    {
        return (strides[0] * (long)i0);
    }
    CUDA_BOTH long offset(int i0, int i1) const
    {
        return (strides[0] * (long)i0) + (strides[1] * (long)i1);
    }
    CUDA_BOTH long offset(int i0, int i1, int i2) const
    {
        return (strides[0] * (long)i0) + (strides[1] * (long)i1) + (strides[2] * (long)i2);
    };
    CUDA_BOTH long offset(int i0, int i1, int i2, int i3) const
    {
        return (strides[0] * (long)i0) + (strides[1] * (long)i1) + (strides[2] * (long)i2) + (strides[3] * (long)i3);
    };
    // clang-format off
    CUDA_BOTH TElem&       operator()(int i0)                               { return *(addr + offset(i0));         }
    CUDA_BOTH TElem&       operator()(int i0, int i1)                       { return *(addr + offset(i0, i1));     }
    CUDA_BOTH TElem&       operator()(int i0, int i1, int i2)               { return *(addr + offset(i0, i1, i2)); }
    CUDA_BOTH TElem&       operator()(int i0, int i1, int i2, int i3)       { return *(addr + offset(i0, i1, i2, i3)); }

    CUDA_BOTH const TElem& operator()(int i0) const                         { return *(addr + offset(i0));         }
    CUDA_BOTH const TElem& operator()(int i0, int i1) const                 { return *(addr + offset(i0, i1));     }
    CUDA_BOTH const TElem& operator()(int i0, int i1, int i2) const         { return *(addr + offset(i0, i1, i2)); }
    CUDA_BOTH const TElem& operator()(int i0, int i1, int i2, int i3) const { return *(addr + offset(i0, i1, i2, i3)); }
    // clang-format on
};

// Lookup tables in constant memory. Some of these are stored either transposed or the conjugate of the MATLAB version
// since they're only used in that format.

// use the inverse value to avoid division operation
static __device__ __constant__ float d_DtxThrExp_inv[CUPHY_PUCCH_F1_MAX_UCI_PER_GRP] = {1.000000,0.738284,0.618357,0.545261,0.494686,0.456735,0.426667,0.402516,0.382375,0.365193,0.350205,0.337286,0.325493,0.315271,0.305854,0.297329,0.289593,0.282405,0.275714,0.269616,0.263918,0.258586,0.253717,0.249027,0.244508,0.240376,0.236380,0.232727,0.229185,0.225750,0.222609,0.219554,0.216582,0.213868,0.211047,0.208469,0.205953,0.203660,0.201258,0.199067,0.196923,0.194973,0.192916,0.191045,0.189069};

static __device__ __constant__ __half2 d_rBase[30][12];
static __half2 rBase[30][12] = {{{-0.707031,0.707031},{0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,-0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031}},
                                 {{0.707031,-0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,-0.707031}},
                                 {{-0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031}},
                                 {{-0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031}},
                                 {{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{-0.707031,-0.707031}},
                                 {{-0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,-0.707031}},
                                 {{0.707031,0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,-0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031}},
                                 {{-0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,-0.707031}},
                                 {{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{-0.707031,0.707031},{0.707031,-0.707031},{0.707031,0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{-0.707031,0.707031}},
                                 {{0.707031,-0.707031},{0.707031,0.707031},{-0.707031,-0.707031},{0.707031,-0.707031},{0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{0.707031,-0.707031}},
                                 {{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{-0.707031,0.707031},{-0.707031,0.707031},{-0.707031,-0.707031},{0.707031,0.707031},{0.707031,0.707031},{0.707031,-0.707031},{-0.707031,-0.707031},{-0.707031,0.707031}}};
                                 
static __device__ __constant__ __half2 d_csPhaseRamp[12][12];
static __half2 csPhaseRamp[12][12]   = {{{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000}},
                                       {{1.000000,0.000000},{0.866211,-0.500000},{0.500000,-0.866211},{0.000000,-1.000000},{-0.500000,-0.866211},{-0.866211,-0.500000},{-1.000000,0.000000},{-0.866211,0.500000},{-0.500000,0.866211},{0.000000,1.000000},{0.500000,0.866211},{0.866211,0.500000}},
                                       {{1.000000,0.000000},{0.500000,-0.866211},{-0.500000,-0.866211},{-1.000000,0.000000},{-0.500000,0.866211},{0.500000,0.866211},{1.000000,0.000000},{0.500000,-0.866211},{-0.500000,-0.866211},{-1.000000,0.000000},{-0.500000,0.866211},{0.500000,0.866211}},
                                       {{1.000000,0.000000},{0.000000,-1.000000},{-1.000000,0.000000},{0.000000,1.000000},{1.000000,0.000000},{0.000000,-1.000000},{-1.000000,0.000000},{0.000000,1.000000},{1.000000,0.000000},{0.000000,-1.000000},{-1.000000,0.000000},{0.000000,1.000000}},
                                       {{1.000000,0.000000},{-0.500000,-0.866211},{-0.500000,0.866211},{1.000000,0.000000},{-0.500000,-0.866211},{-0.500000,0.866211},{1.000000,0.000000},{-0.500000,-0.866211},{-0.500000,0.866211},{1.000000,0.000000},{-0.500000,-0.866211},{-0.500000,0.866211}},
                                       {{1.000000,0.000000},{-0.866211,-0.500000},{0.500000,0.866211},{0.000000,-1.000000},{-0.500000,0.866211},{0.866211,-0.500000},{-1.000000,0.000000},{0.866211,0.500000},{-0.500000,-0.866211},{0.000000,1.000000},{0.500000,-0.866211},{-0.866211,0.500000}},
                                       {{1.000000,0.000000},{-1.000000,0.000000},{1.000000,0.000000},{-1.000000,0.000000},{1.000000,0.000000},{-1.000000,0.000000},{1.000000,0.000000},{-1.000000,0.000000},{1.000000,0.000000},{-1.000000,0.000000},{1.000000,0.000000},{-1.000000,0.000000}},
                                       {{1.000000,0.000000},{-0.866211,0.500000},{0.500000,-0.866211},{0.000000,1.000000},{-0.500000,-0.866211},{0.866211,0.500000},{-1.000000,0.000000},{0.866211,-0.500000},{-0.500000,0.866211},{0.000000,-1.000000},{0.500000,0.866211},{-0.866211,-0.500000}},
                                       {{1.000000,0.000000},{-0.500000,0.866211},{-0.500000,-0.866211},{1.000000,0.000000},{-0.500000,0.866211},{-0.500000,-0.866211},{1.000000,0.000000},{-0.500000,0.866211},{-0.500000,-0.866211},{1.000000,0.000000},{-0.500000,0.866211},{-0.500000,-0.866211}},
                                       {{1.000000,0.000000},{0.000000,1.000000},{-1.000000,0.000000},{0.000000,-1.000000},{1.000000,0.000000},{0.000000,1.000000},{-1.000000,0.000000},{0.000000,-1.000000},{1.000000,0.000000},{0.000000,1.000000},{-1.000000,0.000000},{0.000000,-1.000000}},
                                       {{1.000000,0.000000},{0.500000,0.866211},{-0.500000,0.866211},{-1.000000,0.000000},{-0.500000,-0.866211},{0.500000,-0.866211},{1.000000,0.000000},{0.500000,0.866211},{-0.500000,0.866211},{-1.000000,0.000000},{-0.500000,-0.866211},{0.500000,-0.866211}},
                                       {{1.000000,0.000000},{0.866211,0.500000},{0.500000,0.866211},{0.000000,1.000000},{-0.500000,0.866211},{-0.866211,0.500000},{-1.000000,0.000000},{-0.866211,-0.500000},{-0.500000,-0.866211},{0.000000,-1.000000},{0.500000,-0.866211},{0.866211,-0.500000}}};


//tOCC matrices:                                      
//d_tOCC_1 is a scalar equal to 1
static __device__ __constant__ __half2 d_tOCC_1[1][1];
static __half2 tOCC_1[1][1] = {{{0.000000, 1.000000}}};

static __device__ __constant__ __half2 d_tOCC_2[2][2];
static __half2 tOCC_2[2][2] = {{{1.000000,0.000000},{1.000000,0.000000}},
                              {{1.000000,0.000000},{-1.000000,0.000000}}};

static __device__ __constant__ __half2 d_tOCC_3[3][3];                              
static __half2 tOCC_3[3][3] = {{{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000}},
                              {{1.000000,0.000000},{-0.500000,-0.866211},{-0.500000,0.866211}},
                              {{1.000000,0.000000},{-0.500000,0.866211},{-0.500000,-0.866211}}};

static __device__ __constant__ __half2 d_tOCC_4[4][4];                              
static __half2 tOCC_4[4][4] = {{{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000}},
                              {{1.000000,0.000000},{-1.000000,0.000000},{1.000000,0.000000},{-1.000000,0.000000}},
                              {{1.000000,0.000000},{1.000000,0.000000},{-1.000000,0.000000},{-1.000000,0.000000}},
                              {{1.000000,0.000000},{-1.000000,0.000000},{-1.000000,0.000000},{1.000000,0.000000}}};

static __device__ __constant__ __half2 d_tOCC_5[5][5];                              
static __half2 tOCC_5[5][5] = {{{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000}},
                              {{1.000000,0.000000},{0.309082,-0.951172},{-0.809082,-0.587891},{-0.809082,0.587891},{0.309082,0.951172}},
                              {{1.000000,0.000000},{-0.809082,-0.587891},{0.309082,0.951172},{0.309082,-0.951172},{-0.809082,0.587891}},
                              {{1.000000,0.000000},{-0.809082,0.587891},{0.309082,-0.951172},{0.309082,0.951172},{-0.809082,-0.587891}},
                              {{1.000000,0.000000},{0.309082,0.951172},{-0.809082,0.587891},{-0.809082,-0.587891},{0.309082,-0.951172}}};

static __device__ __constant__ __half2 d_tOCC_6[6][6];                              
static __half2 tOCC_6[6][6] = {{{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000}},
                              {{1.000000,0.000000},{0.500000,-0.866211},{-0.500000,-0.866211},{-1.000000,0.000000},{-0.500000,0.866211},{0.500000,0.866211}},
                              {{1.000000,0.000000},{-0.500000,-0.866211},{-0.500000,0.866211},{1.000000,0.000000},{-0.500000,-0.866211},{-0.500000,0.866211}},
                              {{1.000000,0.000000},{-1.000000,0.000000},{1.000000,0.000000},{-1.000000,0.000000},{1.000000,0.000000},{-1.000000,0.000000}},
                              {{1.000000,0.000000},{-0.500000,0.866211},{-0.500000,-0.866211},{1.000000,0.000000},{-0.500000,0.866211},{-0.500000,-0.866211}},
                              {{1.000000,0.000000},{0.500000,0.866211},{-0.500000,0.866211},{-1.000000,0.000000},{-0.500000,-0.866211},{0.500000,-0.866211}}};

static __device__ __constant__ __half2 d_tOCC_7[7][7];                              
static __half2 tOCC_7[7][7] = {{{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000},{1.000000,0.000000}},
                              {{1.000000,0.000000},{0.623535,-0.781738},{-0.222534,-0.975098},{-0.900879,-0.433838},{-0.900879,0.433838},{-0.222534,0.975098},{0.623535,0.781738}},
                              {{1.000000,0.000000},{-0.222534,-0.975098},{-0.900879,0.433838},{0.623535,0.781738},{0.623535,-0.781738},{-0.900879,-0.433838},{-0.222534,0.975098}},
                              {{1.000000,0.000000},{-0.900879,-0.433838},{0.623535,0.781738},{-0.222534,-0.975098},{-0.222534,0.975098},{0.623535,-0.781738},{-0.900879,0.433838}},
                              {{1.000000,0.000000},{-0.900879,0.433838},{0.623535,-0.781738},{-0.222534,0.975098},{-0.222534,-0.975098},{0.623535,0.781738},{-0.900879,-0.433838}},
                              {{1.000000,0.000000},{-0.222534,0.975098},{-0.900879,-0.433838},{0.623535,-0.781738},{0.623535,0.781738},{-0.900879,0.433838},{-0.222534,-0.975098}},
                              {{1.000000,0.000000},{0.623535,0.781738},{-0.222534,0.975098},{-0.900879,0.433838},{-0.900879,-0.433838},{-0.222534,-0.975098},{0.623535,-0.781738}}};

// frequency domain filter matrix
static __device__ __constant__ __half2 d_Wf[12][12];
static __half2 Wf[12][12] = {{{0.052185,0.0}, {0.053162,0.0}, {0.053436,0.0}, {0.053040,0.0}, {0.051971,0.0}, {0.050262,0.0}, {0.034332,0.0}, {0.029938,0.0}, {0.025330,0.0}, {0.020645,0.0}, {0.015945,0.0}, {0.011337,0.0}},
                             {{0.050598,0.0}, {0.052185,0.0}, {0.053162,0.0}, {0.053436,0.0}, {0.053040,0.0}, {0.051971,0.0}, {0.038483,0.0}, {0.034332,0.0}, {0.029938,0.0}, {0.025330,0.0}, {0.020645,0.0}, {0.015945,0.0}},
                             {{0.048370,0.0}, {0.050598,0.0}, {0.052185,0.0}, {0.053162,0.0}, {0.053436,0.0}, {0.053040,0.0}, {0.042236,0.0}, {0.038483,0.0}, {0.034332,0.0}, {0.029938,0.0}, {0.025330,0.0}, {0.020645,0.0}},
                             {{0.045563,0.0}, {0.048370,0.0}, {0.050598,0.0}, {0.052185,0.0}, {0.053162,0.0}, {0.053436,0.0}, {0.045563,0.0}, {0.042236,0.0}, {0.038483,0.0}, {0.034332,0.0}, {0.029938,0.0}, {0.025330,0.0}},
                             {{0.042236,0.0}, {0.045563,0.0}, {0.048370,0.0}, {0.050598,0.0}, {0.052185,0.0}, {0.053162,0.0}, {0.048370,0.0}, {0.045563,0.0}, {0.042236,0.0}, {0.038483,0.0}, {0.034332,0.0}, {0.029938,0.0}},
                             {{0.038483,0.0}, {0.042236,0.0}, {0.045563,0.0}, {0.048370,0.0}, {0.050598,0.0}, {0.052185,0.0}, {0.050598,0.0}, {0.048370,0.0}, {0.045563,0.0}, {0.042236,0.0}, {0.038483,0.0}, {0.034332,0.0}},
                             {{0.034332,0.0}, {0.038483,0.0}, {0.042236,0.0}, {0.045563,0.0}, {0.048370,0.0}, {0.050598,0.0}, {0.052185,0.0}, {0.050598,0.0}, {0.048370,0.0}, {0.045563,0.0}, {0.042236,0.0}, {0.038483,0.0}},
                             {{0.029938,0.0}, {0.034332,0.0}, {0.038483,0.0}, {0.042236,0.0}, {0.045563,0.0}, {0.048370,0.0}, {0.053162,0.0}, {0.052185,0.0}, {0.050598,0.0}, {0.048370,0.0}, {0.045563,0.0}, {0.042236,0.0}},
                             {{0.025330,0.0}, {0.029938,0.0}, {0.034332,0.0}, {0.038483,0.0}, {0.042236,0.0}, {0.045563,0.0}, {0.053436,0.0}, {0.053162,0.0}, {0.052185,0.0}, {0.050598,0.0}, {0.048370,0.0}, {0.045563,0.0}},
                             {{0.020645,0.0}, {0.025330,0.0}, {0.029938,0.0}, {0.034332,0.0}, {0.038483,0.0}, {0.042236,0.0}, {0.053040,0.0}, {0.053436,0.0}, {0.053162,0.0}, {0.052185,0.0}, {0.050598,0.0}, {0.048370,0.0}},
                             {{0.015945,0.0}, {0.020645,0.0}, {0.025330,0.0}, {0.029938,0.0}, {0.034332,0.0}, {0.038483,0.0}, {0.051971,0.0}, {0.053040,0.0}, {0.053436,0.0}, {0.053162,0.0}, {0.052185,0.0}, {0.050598,0.0}},
                             {{0.011337,0.0}, {0.015945,0.0}, {0.020645,0.0}, {0.025330,0.0}, {0.029938,0.0}, {0.034332,0.0}, {0.050262,0.0}, {0.051971,0.0}, {0.053040,0.0}, {0.053436,0.0}, {0.053162,0.0}, {0.052185,0.0}}};

// centering vector for dmrs                           
static __device__ __constant__ __half2 d_s[12];
static __half2 s[12] = {{1.000000,0.000000},{0.995562,0.094108},{0.982287,0.187381},{0.960294,0.278991},{0.929776,0.368125},{0.891007,0.453990},{0.844328,0.535827},{0.790155,0.612907},{0.728969,0.684547},{0.661312,0.750111},{0.587785,0.809017},{0.509041,0.860742}}; // use the same values as in 5GModel

// time domain filter matrices: (format: m dmrs symbos and n data symbols (n = m, m-1 or m+1) --> d_Wt_m_n)
// We do not need to explicitly store d_Wt_1_1, d_Wt_1_2 and d_Wt_2_1 for the following reasons:
// d_Wt_1_1 is a scalar equal to 1, and d_Wt_1_2 is a vector equal to {{1,0}, {1,0}}. That is, time filtering is not needed if there is only one dmrs symbol.
// d_Wt_2_1 is a vector equal to {{0.5,0}, {0.5,0}}. That is, when there are 2 dmrs symbols and 1 data symbol, we simply take the average over the 2 dmrs symbols.

static __device__ __constant__ __half2 d_Wt_1_1[1][1];
static __half2 Wt_1_1[1][1] = {{{1.00000,0.000000}}};

static __device__ __constant__ __half2 d_Wt_1_2[1][2];
static __half2 Wt_1_2[1][2] = {{{1.00000,0.000000},{1.00000,0.000000}}};

static __device__ __constant__ __half2 d_Wt_2_1[2][1];
static __half2 Wt_2_1[2][1] = {{{0.500000,0.000000}},
                              {{0.500000,0.000000}}};

// To Jim: there should be two types of d_Wt_2_2 matrices: one for dmrs-data-dmrs-data, the other one for data-dmrs-data-dmrs (second hop when nSym == 7) 
static __device__ __constant__ __half2 d_Wt1_2_2[2][2];
static __half2 Wt1_2_2[2][2] = {{{0.500000,0.000000}, {0.500000,0.000000}},
                                {{0.500000,0.000000}, {0.500000,0.000000}}};

static __device__ __constant__ __half2 d_Wt2_2_2[2][2];
static __half2 Wt2_2_2[2][2] = {{{0.500000,0.000000},{0.500000,0.000000}},
                                {{0.500000,0.000000},{0.500000,0.000000}}};                              


static __device__ __constant__ __half2 d_Wt_2_3[2][3];
static __half2 Wt_2_3[2][3] = {{{0.500000,0.000000},{0.500000,0.000000},{0.500000,0.000000}},
                              {{0.500000,0.000000},{0.500000,0.000000},{0.500000,0.000000}}};  

static __device__ __constant__ __half2 d_Wt_3_2[3][2];
static __half2 Wt_3_2[3][2] = {{{0.333252,0.000000},{0.333252,0.000000}},
                              {{0.333252,0.000000},{0.333252,0.000000}},
                              {{0.333252,0.000000},{0.333252,0.000000}}};      

// To Jim: there should be two types of d_Wt_3_3 matrices: one for dmrs-data-dmrs-data-dmrs-data, the other one for data-dmrs-data-dmrs-data-dmrs (second hop when nSym == 11)                               
static __device__ __constant__ __half2 d_Wt1_3_3[3][3];
static __half2 Wt1_3_3[3][3] = {{{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000}},
                                {{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000}},
                                {{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000}}};                               

static __device__ __constant__ __half2 d_Wt2_3_3[3][3];
static __half2 Wt2_3_3[3][3] = {{{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000}},
                                {{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000}},
                                {{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000}}};

static __device__ __constant__ __half2 d_Wt_3_4[3][4];
static __half2 Wt_3_4[3][4] = {{{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000}},
                              {{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000}},
                              {{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000},{0.333252,0.000000}}};
                              
static __device__ __constant__ __half2 d_Wt_4_3[4][3];                              
static __half2 Wt_4_3[4][3] = {{{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000}},
                              {{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000}},
                              {{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000}},
                              {{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000}}};

static __device__ __constant__ __half2 d_Wt_4_4[4][4];       
static __half2 Wt_4_4[4][4] = {{{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000}},
                              {{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000}},
                              {{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000}},
                              {{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000},{0.250000,0.000000}}}; 
                              
static __device__ __constant__ __half2 d_Wt_5_4[5][4];      
static __half2 Wt_5_4[5][4] = {{{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}},
                              {{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}},
                              {{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}},
                              {{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}},
                              {{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}}};     
                              
static __device__ __constant__ __half2 d_Wt_5_5[5][5];                              
static __half2 Wt_5_5[5][5] = {{{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}},
                              {{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}},
                              {{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}},
                              {{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}},
                              {{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000},{0.199951,0.000000}}};

static __device__ __constant__ __half2 d_Wt_6_5[6][5];
static __half2 Wt_6_5[6][5] = {{{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}}};

static __device__ __constant__ __half2 d_Wt_6_6[6][6];     
static __half2 Wt_6_6[6][6] = {{{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}},
                              {{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000},{0.166626,0.000000}}};

static __device__ __constant__ __half2 d_Wt_7_6[7][6]; 
static __half2 Wt_7_6[7][6] = {{{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}}};

static __device__ __constant__ __half2 d_Wt_7_7[7][7];                              
static __half2 Wt_7_7[7][7] = {{{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}},
                              {{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000},{0.142822,0.000000}}};

static constexpr uint32_t N_TONES_PER_PRB = 12;
static constexpr uint32_t NOISE_FILT_LEN = 8;

static __device__ __constant__ __half d_W_noiseIso[NOISE_FILT_LEN][N_TONES_PER_PRB];
static __half W_noiseIso[NOISE_FILT_LEN][N_TONES_PER_PRB] = {{0.377686,-0.291260,-0.370117,-0.152710, 0.127808, 0.309570, 0.309570, 0.127808,-0.152710,-0.370117,-0.291260, 0.377686},
                                  {-0.268066, 0.449219, 0.174561,-0.223267,-0.347656,-0.159058, 0.159058, 0.347656, 0.223267,-0.174561,-0.449219, 0.268066},
                                  {-0.168213, 0.464600,-0.156860,-0.373047,-0.063110, 0.296631, 0.296631,-0.063110,-0.373047,-0.156860, 0.464600,-0.168213},
                                  { 0.092529,-0.372070, 0.406250, 0.142944,-0.325684,-0.248169, 0.240601, 0.346680,-0.168335,-0.388916, 0.365723,-0.091492},
                                  { 0.039154,-0.215210, 0.411377,-0.170654,-0.467773, 0.626953,-0.064941,-0.319824, 0.127197, 0.104431,-0.090149, 0.019287},
                                  { 0.019623,-0.117859, 0.274170,-0.294678, 0.135010,-0.036469,-0.028397, 0.319580,-0.613770, 0.524902,-0.218384, 0.036285},
                                  { 0.003120,-0.045746, 0.214233,-0.454834, 0.394531, 0.137207,-0.545898, 0.282715, 0.223022,-0.341553, 0.160522,-0.027527},
                                  { 0.019958,-0.124451, 0.314453,-0.412842, 0.341553,-0.338867, 0.478271,-0.459229, 0.206421,-0.002653,-0.030899, 0.007957}};

 
static constexpr uint32_t LOWER_BYTE_BMSK = 255;
static constexpr uint32_t N_TA_EST_SC = 11;
static constexpr uint32_t MU_0_HZ = 15000;
static constexpr float    RAD_TO_USEC = 1000000.0/(2.0*M_PI);

// Values copied from MATLAB for different numbers of Rx antennas
static constexpr float ALPHA_DEFAULT = 92.5;
static constexpr float ALPHA_R1R2    = 31.0/3;
static constexpr float ALPHA_R3R4R5  = 23.5;

static constexpr float MAX_SINR   = 65.6; // Maximum reportable SINR
static constexpr float MIN_SINR   =-65.6; // Minimum reportable SINR

 static __global__ void
 pucchF1RxKernel(pucchF1RxDynDescr_t* pDynDescr)
 {
   auto block = cg::this_thread_block();
   auto tile  = cg::tiled_partition<F1_CG_SIZE>(block);

   // Global UCI group across all CTAs
   uint16_t global_group = blockIdx.x;

   if (global_group >= pDynDescr->numUciGrps) {
      return;
   }

   // UCI group local to this CTA
   auto local_group = tile.meta_group_rank();

   // UCI data for this group
   auto group_data = &pDynDescr->uciGrpPrms[global_group];

   // cell idx
   auto    cellIdx  = group_data->cellIdx;
   int16_t numRxAnt = pDynDescr->pCellPrms[cellIdx].nRxAnt;

   // Shared memory for each group. This can be optimized later by dynamically launching based on the actual antennas
   // and data/dmrs symbols
   __shared__ __half2 y_data[F1_UCIS_PER_GROUP * MAX_DATA_SYMS_F1 * N_TONES_PER_PRB * F1_MAX_RX_ANTENNA];
   __shared__ __half2 y_dmrs[F1_UCIS_PER_GROUP * MAX_DMRS_SYMS_F1 * N_TONES_PER_PRB * F1_MAX_RX_ANTENNA];
   __shared__ __half2 r1[F1_UCIS_PER_GROUP * N_TONES_PER_PRB];
   __shared__ __half2 r2[F1_UCIS_PER_GROUP * N_TONES_PER_PRB];
   __shared__ __half2 dmrs_per_uci[F1_UCIS_PER_GROUP * N_TONES_PER_PRB * MAX_DMRS_SYMS_F1 * F1_MAX_RX_ANTENNA];
   __shared__ __half2 data_per_uci[F1_UCIS_PER_GROUP * N_TONES_PER_PRB * MAX_DATA_SYMS_F1 * F1_MAX_RX_ANTENNA];
   __shared__ __half2 h_est_iue[F1_UCIS_PER_GROUP * MAX_DATA_SYMS_F1 * N_TONES_PER_PRB * F1_MAX_RX_ANTENNA];

   // Per-group shared memory carveouts
   __half2 *group_data_s            = &y_data[local_group * MAX_DATA_SYMS_F1 * N_TONES_PER_PRB * F1_MAX_RX_ANTENNA];
   __half2 *group_dmrs_s            = &y_dmrs[local_group * MAX_DMRS_SYMS_F1 * N_TONES_PER_PRB * F1_MAX_RX_ANTENNA];
   __half2 *group_h_est_iue         = &h_est_iue[local_group * MAX_DATA_SYMS_F1 * N_TONES_PER_PRB * F1_MAX_RX_ANTENNA];
   __half2 *group_r1                = &r1[local_group * N_TONES_PER_PRB];
   __half2 *group_r2                = &r2[local_group * N_TONES_PER_PRB];
   __half2 *group_dmrs_per_uci      = &dmrs_per_uci[local_group * N_TONES_PER_PRB * MAX_DMRS_SYMS_F1 * F1_MAX_RX_ANTENNA];
   __half2 *group_data_per_uci      = &data_per_uci[local_group * N_TONES_PER_PRB * MAX_DATA_SYMS_F1 * F1_MAX_RX_ANTENNA];     

   // Populate group sequences using gold codes
   {
      uint16_t pucchHoppingId = pDynDescr->pCellPrms[cellIdx].pucchHoppingId;
      uint16_t slotNum        = pDynDescr->pCellPrms[cellIdx].slotNum;
      // sequence number (38.211 6.3.2.2.1)
      if(group_data->groupHopFlag == 0)
      {
         group_data->u[0] = pucchHoppingId % 30;
         group_data->u[1] = pucchHoppingId % 30;
      }else
      {
         uint32_t g   = descrambling::gold32n(pucchHoppingId / 30, 16 * slotNum);
         uint8_t f_ss = pucchHoppingId % 30;

         // first hop
         uint8_t f_gh = (g & LOWER_BYTE_BMSK) % 30;
         group_data->u[0] = (f_ss + f_gh) % 30;

         // second hop
         if(group_data->freqHopFlag)
         {
            f_gh = ((g >> 8) & LOWER_BYTE_BMSK) % 30;
            group_data->u[1] = (f_ss + f_gh) % 30;

         }else
         {
            group_data->u[1] = group_data->u[0];
         } 
      }

      // common cyclic shift (38.211 6.3.2.2.2)

      uint8_t  startSymTemp = group_data->startSym;
      uint8_t  Counter = 0;

      uint32_t g  = descrambling::gold32n(pucchHoppingId, 14*8*slotNum + 8*startSymTemp);
      
      for(int i = 0; i < group_data->nSym; i++)
      {
         if (Counter == 4)
         {
            startSymTemp += 4;
            g = descrambling::gold32n(pucchHoppingId, 14*8*slotNum + 8*startSymTemp);
            Counter = 0;
         }

         group_data->csCommon[i] = (g >> (Counter*8) & LOWER_BYTE_BMSK);
         Counter++;
      }
   }

   tensor_ref<const __half2> tDataRx(pDynDescr->pCellPrms[cellIdx].tDataRx.pAddr, pDynDescr->pCellPrms[cellIdx].tDataRx.strides);

   // Lane without our group
   int lane   = tile.thread_rank();  

   float rssi = 0;   
   __half2 tmp;


   // Pull in all values needed to construct Y_pucch from the MATLAB code. Because of the relatively low amount of data to fetch, and the
   // layout of this data, the access patterns are not ideal. We rely heavily on the L2 cache to make this fast, but this can be optimized
   // if it's a hot spot. Right now this is < 10% of the total kernel time. We also accumulate RSSI as we go instead of afterwards to avoid
   // an extra loop.
   //
   // Note that the data and DMRS symbols are separated here to make the processing easier later
   if (lane < N_TONES_PER_PRB) {
      int firstHopSc = (group_data->startCrb)*CUPHY_N_TONES_PER_PRB + lane;
      if (group_data->freqHopFlag) {
         for (int sym = group_data->startSym; sym < group_data->startSym + group_data->nSymFirstHop; sym++) {
            if ((sym - group_data->startSym) & 1) {
               for (int a = 0; a < numRxAnt; a++) {
                  group_data_s[lane*group_data->nSym_data*numRxAnt +  (sym-group_data->startSym)/2*numRxAnt + a] = tDataRx(firstHopSc, sym, a);
               }
            }
            else {
               for (int a = 0; a < numRxAnt; a++) {
                  tmp = tDataRx(firstHopSc, sym, a);
                  group_dmrs_s[lane*group_data->nSym_dmrs*numRxAnt +  (sym-group_data->startSym)/2*numRxAnt + a] = tmp;
                  rssi += __half2float(tmp.x*tmp.x + tmp.y*tmp.y);
               }
            }
         }

         int secondHopSc = (group_data->secondHopCrb)*CUPHY_N_TONES_PER_PRB + lane;
         for (int sym = group_data->startSym + group_data->nSymFirstHop; sym < group_data->startSym + group_data->nSym; sym++) {
            if ((sym - group_data->startSym) & 1) {
               for (int a = 0; a < numRxAnt; a++) {
                  group_data_s[lane*group_data->nSym_data*numRxAnt + (sym-group_data->startSym)/2*numRxAnt + a] = tDataRx(secondHopSc, sym, a);
               }
            }
            else {
               for (int a = 0; a < numRxAnt; a++) {
                  tmp = tDataRx(secondHopSc, sym, a);
                  group_dmrs_s[lane*group_data->nSym_dmrs*numRxAnt + (sym-group_data->startSym)/2*numRxAnt + a] = tmp;
                  rssi += __half2float(tmp.x*tmp.x + tmp.y*tmp.y);
               }
            }
         }            
      }
      else {
         for (int sym = group_data->startSym; sym < group_data->startSym + group_data->nSym; sym++) {
            if ((sym - group_data->startSym) & 1) {
               for (int a = 0; a < numRxAnt; a++) {
                  group_data_s[lane*group_data->nSym_data*numRxAnt + (sym-group_data->startSym)/2*numRxAnt + a] = tDataRx(firstHopSc, sym, a);
               }
            }
            else {
               for (int a = 0; a < numRxAnt; a++) {
                  tmp = tDataRx(firstHopSc, sym, a);
                  group_dmrs_s[lane*group_data->nSym_dmrs*numRxAnt + (sym-group_data->startSym)/2*numRxAnt + a] = tmp;
                  rssi += __half2float(tmp.x*tmp.x + tmp.y*tmp.y);
               }
            }
         }         
      }
   }

   // Fetch rBase values for first and second hop
   if (lane < N_TONES_PER_PRB) {
      group_r1[lane] = d_rBase[group_data->u[0]][lane];  

      if (group_data->freqHopFlag && group_data->groupHopFlag) {
         group_r2[lane] = d_rBase[group_data->u[1]][lane];
      }
      else {
         group_r2[lane] = d_rBase[group_data->u[0]][lane];
      }  
   } 

   tile.sync();
   
   #ifdef ENABLE_DEBUG_F1
      if (0 && (group_data->uciOutputIdx[0]==0)&&(lane < N_TONES_PER_PRB)){
            __half2 tmp_group_r1 = group_r1[lane];
            printf("group_r1=%f, lane=%d\n", __half2float(tmp_group_r1.y),lane);
            __half2 tmp_d_s = d_s[lane];
            printf("d_s=%f, lane=%d\n", __half2float(tmp_d_s.y),lane);
      }
   #endif
   
   float rssi_linear = cg::reduce(tile, rssi, cg::plus<float>()) / 
                              static_cast<float>(group_data->nSym_dmrs);
   float rssi_dB = 10.0f * __log10f(rssi_linear);
   rssi_linear /= numRxAnt;
   rssi_linear /= N_TONES_PER_PRB;

   float alpha = ALPHA_DEFAULT;
   if (numRxAnt < 3) {
      alpha = ALPHA_R1R2;
   } else if (numRxAnt < 6) {
      alpha = ALPHA_R3R4R5;
   }

   // Compute DMRS centered and scale the data symbols by rBase. We reuse the same shared memory since the original
   // values are not needed anymore
   if (group_data->freqHopFlag) {
      for (int prb = 0; prb < N_TONES_PER_PRB; prb++) {
         for (int i = lane; 
                  i < numRxAnt*group_data->nSymDataFirstHop;
                  i += tile.size()) {
            group_data_s[prb*numRxAnt*group_data->nSym_data + i] =
                  complex_mul(group_r1[prb], group_data_s[prb*numRxAnt*group_data->nSym_data + i]);
         }

         for (int i = lane; 
                  i < numRxAnt*group_data->nSymDMRSFirstHop;
                  i += tile.size()) {
            group_dmrs_s[prb*numRxAnt*group_data->nSym_dmrs + i] =
               complex_mul(group_r1[prb], complex_mul(d_s[prb], group_dmrs_s[prb*numRxAnt*group_data->nSym_dmrs + i]));
         } 

         for (int i = numRxAnt*group_data->nSymDataFirstHop + lane;
                  i < numRxAnt*group_data->nSym_data;
                  i += tile.size()) {
            group_data_s[prb*numRxAnt*group_data->nSym_data + i] =
               complex_mul(group_r2[prb], group_data_s[prb*numRxAnt*group_data->nSym_data + i]);
         }

         for (int i = numRxAnt*group_data->nSymDMRSFirstHop + lane;
                  i < numRxAnt*group_data->nSym_dmrs;
                  i += tile.size()) {
            group_dmrs_s[prb*numRxAnt*group_data->nSym_dmrs + i] =
               complex_mul(group_r2[prb], complex_mul(d_s[prb], group_dmrs_s[prb*numRxAnt*group_data->nSym_dmrs + i]));
         }       
      }
   }
   else { // No hopping
      for (int prb = 0; prb < N_TONES_PER_PRB; prb++) {
         for (int i = lane; 
                  i < numRxAnt*group_data->nSym_data;
                  i += tile.size()) {
            group_data_s[prb*numRxAnt*group_data->nSym_data + i] =
               complex_mul(group_r1[prb], group_data_s[prb*numRxAnt*group_data->nSym_data + i]);
         }
         for (int i = lane; 
                  i < numRxAnt*group_data->nSym_dmrs;
                  i += tile.size()) {
            group_dmrs_s[prb*numRxAnt*group_data->nSym_dmrs + i] =
               complex_mul(group_r1[prb], complex_mul(d_s[prb], group_dmrs_s[prb*numRxAnt*group_data->nSym_dmrs + i]));
         }         
      }   
   }

   tile.sync();

   // Pointers to LUTs based on number of symbols
   __half2 *tocc_tables[] = {(__half2*)d_tOCC_1, (__half2*)d_tOCC_2, (__half2*)d_tOCC_3, (__half2*)d_tOCC_4, (__half2*)d_tOCC_5, (__half2*)d_tOCC_6, (__half2*)d_tOCC_7};

   // UCI processing for each group. Each CG co-processes a single UCI at a time.
   for (int uci = local_group; uci < group_data->nUciInGrp; uci += tile.meta_group_size()) {
      float dtx_thresh = __powf(rssi_linear, 1.88) * alpha * __half2float(group_data->DTXthreshold[uci]) * d_DtxThrExp_inv[group_data->nUciInGrp-1];
      if (dtx_thresh < 1e-16) {
         dtx_thresh = 1e-16;
      }
      uint32_t uciIdx = group_data->uciOutputIdx[uci];
      uint32_t cs[F1_MAX_SYMS];

      // This is an error condition, so set the bits and move on.
      if (group_data->bitLenHarq[uci] == 0 && !group_data->srFlag[uci]) {
         if (lane == 0) {
            pDynDescr->pF1UcisOut[uciIdx].SinrDB              = -99; // Set default value
            pDynDescr->pF1UcisOut[uciIdx].InterfDB            = -99; // Set default value
            pDynDescr->pF1UcisOut[uciIdx].NumHarq             = 0;
            pDynDescr->pF1UcisOut[uciIdx].SRindication        = 0;
            pDynDescr->pF1UcisOut[uciIdx].SRconfidenceLevel   = 1;
            pDynDescr->pF1UcisOut[uciIdx].HarqconfidenceLevel = 1;
            pDynDescr->pF1UcisOut[uciIdx].taEstMicroSec       = 0;
         }

         continue;
      }
      
      // Set up cs index array
      for (int i = 0; i < group_data->nSym; i++) {
         cs[i] = (group_data->csCommon[i] + group_data->cs0[uci]) % 12;
      }

      // Construct the data and DMRS per-UCI symbols. This translated to the following MATLAB code:
      /*
               DMRS: conj(tOCC_dmrs{1}(tOCCidx+1,i)) * conj(csPhaseRamp(:,cs(2*(i-1)+1)+1)) .* Y_dmrs_centered(:,i,bs);
               Data: conj(tOCC_data{1}(tOCCidx+1,i)) * conj(csPhaseRamp(:,cs(2*(i-1)+2)+1)) .* . Y_data(:,i,bs);
      */
      if (lane < N_TONES_PER_PRB) {
         if (group_data->freqHopFlag) {
            for (int sym = 0; sym < group_data->nSymDMRSFirstHop; sym++) {
               for (int ant = 0; ant < numRxAnt; ant++) {
                  group_dmrs_per_uci[lane*group_data->nSym_dmrs*numRxAnt + sym*numRxAnt + ant] =
                        complex_mul(
                              complex_mul(tocc_tables[group_data->nSymDMRSFirstHop-1][group_data->timeDomainOccIdx[uci]*group_data->nSymDMRSFirstHop + sym], 
                                 d_csPhaseRamp[lane][cs[2*sym]]),
                           group_dmrs_s[lane*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant]);
               }
            }

            for (int sym = 0; sym < group_data->nSymDataFirstHop; sym++) {
               for (int ant = 0; ant < numRxAnt; ant++) {
                  group_data_per_uci[lane*group_data->nSym_data*numRxAnt + sym*numRxAnt + ant] =
                        complex_mul(
                           complex_mul(tocc_tables[group_data->nSymDataFirstHop-1][group_data->timeDomainOccIdx[uci]*group_data->nSymDataFirstHop + sym], 
                              d_csPhaseRamp[lane][cs[2*sym + 1]]),
                           group_data_s[lane*numRxAnt*group_data->nSym_data + sym*numRxAnt + ant]);
               }
            }
        
            for (int sym = group_data->nSymDMRSFirstHop; sym < group_data->nSym_dmrs; sym++) {
               for (int ant = 0; ant < numRxAnt; ant++) {
                  group_dmrs_per_uci[lane*group_data->nSym_dmrs*numRxAnt + sym*numRxAnt + ant] =
                        complex_mul(
                           complex_mul(tocc_tables[group_data->nSymDMRSSecondHop-1][group_data->timeDomainOccIdx[uci]*group_data->nSymDMRSSecondHop + (sym-group_data->nSymDMRSFirstHop)], 
                              d_csPhaseRamp[lane][cs[2*sym]]),
                           group_dmrs_s[lane*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant]);
               }
            }

            for (int sym = group_data->nSymDataFirstHop; sym < group_data->nSym_data; sym++) {
               for (int ant = 0; ant < numRxAnt; ant++) {
                  group_data_per_uci[lane*group_data->nSym_data*numRxAnt + sym*numRxAnt + ant] =
                        complex_mul(
                           complex_mul(tocc_tables[group_data->nSymDataSecondHop-1][group_data->timeDomainOccIdx[uci]*group_data->nSymDataSecondHop + (sym-group_data->nSymDataFirstHop)], 
                              d_csPhaseRamp[lane][cs[2*sym + 1]]),
                           group_data_s[lane*numRxAnt*group_data->nSym_data + sym*numRxAnt + ant]);
               }
            }        
            
         }
         else {
            for (int sym = 0; sym < group_data->nSym_dmrs; sym++) {
               for (int ant = 0; ant < numRxAnt; ant++) {
                  group_dmrs_per_uci[lane*group_data->nSym_dmrs*numRxAnt + sym*numRxAnt + ant] =
                        complex_mul(
                           complex_mul(tocc_tables[group_data->nSym_dmrs-1][group_data->timeDomainOccIdx[uci]*group_data->nSym_dmrs + sym], 
                              d_csPhaseRamp[lane][cs[2*sym]]),
                           group_dmrs_s[lane*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant]);
               }
            }

            for (int sym = 0; sym < group_data->nSym_data; sym++) {
               for (int ant = 0; ant < numRxAnt; ant++) {
                  group_data_per_uci[lane*group_data->nSym_data*numRxAnt + sym*numRxAnt + ant] =
                        complex_mul(
                           complex_mul(tocc_tables[group_data->nSym_data-1][group_data->timeDomainOccIdx[uci]*group_data->nSym_data + sym], 
                              d_csPhaseRamp[lane][cs[2*sym + 1]]),
                           group_data_s[lane*numRxAnt*group_data->nSym_data + sym*numRxAnt + ant]);
               }
            }
         }
      }

      tile.sync();

      // Apply noise isolation filter to each symbol and sum results to compute noise energy
      float noiseEngAccum = 0.0;
      for(int i = lane; i < (group_data->nSym_dmrs*numRxAnt*NOISE_FILT_LEN); i+=tile.size()) {
         int sym = i / (NOISE_FILT_LEN * numRxAnt);
         int a  = (i / NOISE_FILT_LEN) % numRxAnt;
         int b  =  i % NOISE_FILT_LEN;
         float2 element = {0.0,0.0};
         for(int sc = 0; sc < N_TONES_PER_PRB; sc++) {
            element = complex_add(element,
                        __half22float2(
                           real_mul(group_dmrs_per_uci[sc*group_data->nSym_dmrs*numRxAnt + sym*numRxAnt + a], d_W_noiseIso[b][sc])));
         }
            noiseEngAccum += element.x*element.x + element.y*element.y;
      }

      // Compute timing advance by correlating across subcarriers
      __half2 avg_sc_corr = {0.0,0.0};
      for(int i = lane; i< (N_TA_EST_SC*group_data->nSym_dmrs*numRxAnt); i+=tile.size())
      {
         int sc  =  i / (group_data->nSym_dmrs*numRxAnt);
         int sym = (i / numRxAnt) % group_data->nSym_dmrs;
         int a   =  i % numRxAnt;
         avg_sc_corr += complex_conjmul(complex_conjmul(group_dmrs_per_uci[(sc+1) * group_data->nSym_dmrs * numRxAnt + sym*numRxAnt + a],d_s[sc+1]),
                                        complex_conjmul(group_dmrs_per_uci[ sc    * group_data->nSym_dmrs * numRxAnt + sym*numRxAnt + a],d_s[sc  ]));
      }
      tile.sync();

      avg_sc_corr = cg::reduce(tile, avg_sc_corr, cg::plus<__half2>());
      float angle = atan2f(__half2float(avg_sc_corr.y),__half2float(avg_sc_corr.x));
      uint32_t scs = MU_0_HZ<<pDynDescr->pCellPrms[cellIdx].mu;
      float taEstMicroSec = -RAD_TO_USEC*angle/float(scs);

      float avgNoiseAndIntEnergy = cg::reduce(tile,noiseEngAccum, cg::plus<float>())/(group_data->nSym_dmrs*numRxAnt*NOISE_FILT_LEN);
      float avgSignalEnergy = rssi_linear - avgNoiseAndIntEnergy;
      float interf_dB   = 10.0f * __log10f(avgNoiseAndIntEnergy); 
      float sinr_dB     = 10.0f * __log10f(fabs(avgSignalEnergy)) - interf_dB;
      if(avgSignalEnergy <= 0.0f) {
         sinr_dB = MIN_SINR;
      }
      sinr_dB = std::min({MAX_SINR, sinr_dB});
      sinr_dB = std::max({MIN_SINR, sinr_dB});

      __half2 *Wt_table_h1;
      __half2 *Wt_table_h2;
      __half2 temp_t_dmrs;
      float2 tempf_t_dmrs;
      float qam_est_x = 0.0;
      float qam_est_y = 0.0; 
      float rsrpTemp  = 0.0;
      float rsrp_dB   = 0.0;

      /*
         Compute H_est_iue. The frequency hopping case is not as straightforward as the non-hopping case since the number
         of symbols used can vary based on the hop. The lookup table sizes for Wt also vary across hops. The main steps here are:
         1) Look up Wt matrices
         2) Compute H_est_iue = conj(s) .* ((Wf * Y_dmrs/data_perUci) * Wt)
         3) Compute m = Y_data_perUci .* conj(H_est_iue);
         4) Make a QAM estimate

         Step 2 is somewhat complicated in that we don't want to allocate extra memory to store the intermediate GEMM of
         C = (Wf * Y_dmrs/data_perUci), so after each cell of C is computed, we use it to compute accumulated results of
         C * Wt. The accumulated values are stored in shared memory, and the GEMMs are both computed at the same time. Each lane
         processes a single row of C, which means it's also responsible for only a single row in the final outer GEMM. We
         also apply conj(s) as we go to each element instead of once outside to avoid an extra loop. Similarly, the QAM
         estimate is accumulated per-thread, and only after this stage is done is the final value ready.

         The group_h_est_iue shared memory array is cleared and reused after each hop and UCI since the only thing needed
         from it was the QAM estimate.
      */

      if (group_data->freqHopFlag) {
         // Zero out the initial shared memory to re-use for GEMM accumulators
         for (int i = lane; i < MAX_DATA_SYMS_F1 * N_TONES_PER_PRB * F1_MAX_RX_ANTENNA; i += F1_CG_SIZE) {
            group_h_est_iue[i] = {0.0, 0.0};
         }  

         // calculate RSRP
         for (int ant = 0; ant < numRxAnt; ant++) {
            // first hop
            temp_t_dmrs = {0.0, 0.0};
            if (lane < N_TONES_PER_PRB) {
               for (int sym = 0; sym < group_data->nSymDMRSFirstHop; sym++) {
                  temp_t_dmrs += group_dmrs_per_uci[lane*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant];
               }
               temp_t_dmrs = complex_conjmul(temp_t_dmrs, d_s[lane]);
            }
            tile.sync();
            temp_t_dmrs = cg::reduce(tile, temp_t_dmrs, cg::plus<__half2>());
            tempf_t_dmrs.x = __half2float(temp_t_dmrs.x)/static_cast<float>(N_TONES_PER_PRB)/static_cast<float>(group_data->nSymDMRSFirstHop);
            tempf_t_dmrs.y = __half2float(temp_t_dmrs.y)/static_cast<float>(N_TONES_PER_PRB)/static_cast<float>(group_data->nSymDMRSFirstHop);
            rsrpTemp += tempf_t_dmrs.x*tempf_t_dmrs.x + tempf_t_dmrs.y*tempf_t_dmrs.y;

            // second hop
            temp_t_dmrs = {0.0, 0.0};
            if (lane < N_TONES_PER_PRB) {
               for (int sym = group_data->nSymDMRSFirstHop; sym < group_data->nSym_dmrs; sym++) {
                  temp_t_dmrs += group_dmrs_per_uci[lane*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant];
               }
               temp_t_dmrs = complex_conjmul(temp_t_dmrs, d_s[lane]);
            }
            tile.sync();
            temp_t_dmrs = cg::reduce(tile, temp_t_dmrs, cg::plus<__half2>());
            tempf_t_dmrs.x = __half2float(temp_t_dmrs.x)/static_cast<float>(N_TONES_PER_PRB)/static_cast<float>(group_data->nSymDMRSSecondHop);
            tempf_t_dmrs.y = __half2float(temp_t_dmrs.y)/static_cast<float>(N_TONES_PER_PRB)/static_cast<float>(group_data->nSymDMRSSecondHop);
            rsrpTemp += tempf_t_dmrs.x*tempf_t_dmrs.x + tempf_t_dmrs.y*tempf_t_dmrs.y;
         }
         rsrp_dB = 10.0f * __log10f(rsrpTemp/2.0/static_cast<float>(numRxAnt));

         if (lane < N_TONES_PER_PRB) {
            switch (group_data->nSym) {
               case 4: Wt_table_h1 = (__half2 *)d_Wt_1_1;  Wt_table_h2 = (__half2 *)d_Wt_1_1; break;
               case 5: Wt_table_h1 = (__half2 *)d_Wt_1_1;  Wt_table_h2 = (__half2 *)d_Wt_2_1; break;
               case 6: Wt_table_h1 = (__half2 *)d_Wt_2_1;  Wt_table_h2 = (__half2 *)d_Wt_1_2; break;
               case 7: Wt_table_h1 = (__half2 *)d_Wt_2_1;  Wt_table_h2 = (__half2 *)d_Wt2_2_2; break;
               case 8: Wt_table_h1 = (__half2 *)d_Wt1_2_2;  Wt_table_h2 = (__half2 *)d_Wt1_2_2; break;
               case 9: Wt_table_h1 = (__half2 *)d_Wt1_2_2;  Wt_table_h2 = (__half2 *)d_Wt1_2_2; break;
               case 10: Wt_table_h1 = (__half2 *)d_Wt1_2_2;  Wt_table_h2 = (__half2 *)d_Wt_2_3; break;
               case 11: Wt_table_h1 = (__half2 *)d_Wt1_2_2;  Wt_table_h2 = (__half2 *)d_Wt2_3_3; break;
               case 12: Wt_table_h1 = (__half2 *)d_Wt1_3_3;  Wt_table_h2 = (__half2 *)d_Wt1_3_3; break;
               case 13: Wt_table_h1 = (__half2 *)d_Wt1_3_3;  Wt_table_h2 = (__half2 *)d_Wt_4_3; break;
               case 14: Wt_table_h1 = (__half2 *)d_Wt_4_3;  Wt_table_h2 = (__half2 *)d_Wt_3_4; break;
               default: break;
            }
            
            // To conserve memory, we need to do a double-GEMM here so that we don't have to store the intermediate results. See comment above
            for (int ant = 0; ant < numRxAnt; ant++) {
               for (int sym = 0; sym < group_data->nSymDMRSFirstHop; sym++) {     
                  __half2 accum = {0.0, 0.0};       
                  for (int i = 0; i < N_TONES_PER_PRB; i++) { // Cols of Wf. Each lane processes a single row
                     accum = __hadd2(accum, 
                        complex_mul(group_dmrs_per_uci[i*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant],d_Wf[lane][i]));
                  }
                  #ifdef ENABLE_DEBUG_F1
                     if (0 && (ant==0)&&(sym==0)&&(lane==0)){
                        int uci_idx = group_data->uciOutputIdx[0];
                        printf("uci_idx=%d, accum_after_Wf=%f\n", uci_idx, __half2float(accum.x));
                        if (uci_idx==0){
                           for (int i = 0; i < N_TONES_PER_PRB; i++){
                              __half2 tmp = group_dmrs_per_uci[i*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant];
                              printf("group_dmrs_per_uci[%d]=%f\n",i,__half2float(tmp.x));
                           }
                        }
                     }          
                  #endif
                  // Now we have the accumulated value from one cell in C = A*B. Now use that value to sweep over E = C*D. We also apply the element-wise
                  // multiply by conj(s) here as well to avoid more loops
                  for (int E_col = 0; E_col < group_data->nSymDataFirstHop; E_col++) {
                     group_h_est_iue[lane*numRxAnt*group_data->nSymDataFirstHop + E_col*numRxAnt + ant] +=
                        complex_conjmul(complex_mul(accum, Wt_table_h1[sym*group_data->nSymDataFirstHop + E_col]), d_s[lane]);
                  }
               }
            }
         }

         tile.sync();

         // Compute step 3 in the comment above
         if (lane < N_TONES_PER_PRB) {
            for (int sym = 0; sym < group_data->nSymDataFirstHop; sym++) {
               for (int ant = 0; ant < numRxAnt; ant++) {
                  __half2 tmp = complex_conjmul(group_data_per_uci[lane*numRxAnt*group_data->nSym_data + sym*numRxAnt + ant],
                                    group_h_est_iue[lane*numRxAnt*group_data->nSymDataFirstHop + sym*numRxAnt + ant]);

                  qam_est_x += __half2float(tmp.x);
                  qam_est_y += __half2float(tmp.y);
               }
            }
         }

         // Sync is needed since we blow away group_h_est_iue right after this
         tile.sync();
         #ifdef ENABLE_DEBUG_F1
            if (0 && (lane == 0)) {
               __half2 my_data = group_data_per_uci[0];
               __half2 my_dmrs = group_h_est_iue[0];
               __half2 my_ori_dmrs = group_dmrs_per_uci[0];
               printf("uci_idx=%d, group_data_per_uci=%f, group_h_est_iue=%f, group_dmrs_per_uci=%f\n", group_data->uciOutputIdx[0], __half2float(my_data.x),__half2float(my_dmrs.x), __half2float(my_ori_dmrs.x));
               printf("uci_idx=%d, qam_est_x=%f, qam_est_y=%f\n", group_data->uciOutputIdx[0], cg::reduce(tile, qam_est_x, cg::plus<float>()), cg::reduce(tile, qam_est_y, cg::plus<float>()));
            }       
         #endif
         for (int i = lane; i < MAX_DATA_SYMS_F1 * N_TONES_PER_PRB * F1_MAX_RX_ANTENNA; i += F1_CG_SIZE) {
            group_h_est_iue[i] = {0.0, 0.0};
         }  

         tile.sync();  

         // Second hop
         if (lane < N_TONES_PER_PRB) {      
            for (int ant = 0; ant < numRxAnt; ant++) {
               for (int sym = group_data->nSymDMRSFirstHop; sym < group_data->nSym_dmrs; sym++) {     
                  __half2 accum = {0.0, 0.0};       
                  for (int i = 0; i < N_TONES_PER_PRB; i++) { // Cols of Wf. Each lane processes a single row
                     accum = __hadd2(accum, 
                        complex_mul(group_dmrs_per_uci[i*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant],d_Wf[lane][i]));
                  }

                  // Now we have the accumulated value from one cell in C = A*B. Now use that value to sweep over E = C*D. We also apply the element-wise
                  // multiply by conj(s) here as well to avoid more loops
                  for (int E_col = 0; E_col < group_data->nSymDataSecondHop; E_col++) {
                     group_h_est_iue[lane*numRxAnt*group_data->nSymDataSecondHop + E_col*numRxAnt + ant] +=
                        complex_conjmul(complex_mul(accum, Wt_table_h2[(sym-group_data->nSymDMRSFirstHop)*group_data->nSymDataSecondHop + E_col]), d_s[lane]);  
                  }
               }
            }
         }

         tile.sync();

         if (lane < N_TONES_PER_PRB) {         
            for (int sym = group_data->nSymDataFirstHop; sym < group_data->nSym_data; sym++) {
               for (int ant = 0; ant < numRxAnt; ant++) {
                  __half2 tmp = complex_conjmul(group_data_per_uci[lane*numRxAnt*group_data->nSym_data + sym*numRxAnt + ant],
                                    group_h_est_iue[lane*numRxAnt*group_data->nSymDataSecondHop + (sym - group_data->nSymDataFirstHop)*numRxAnt + ant]);

                  qam_est_x += __half2float(tmp.x);
                  qam_est_y += __half2float(tmp.y);
                  
               }
            }              
         }

         //tile.sync();  
         
      }
      else {
         for (int i = lane; i < MAX_DATA_SYMS_F1 * N_TONES_PER_PRB * F1_MAX_RX_ANTENNA; i += F1_CG_SIZE) {
            group_h_est_iue[i] = {0.0, 0.0};
         }  

         for (int ant = 0; ant < numRxAnt; ant++) {
            temp_t_dmrs = {0.0, 0.0};
            if (lane < N_TONES_PER_PRB) {
               for (int sym = 0; sym < group_data->nSym_dmrs; sym++) {
                  temp_t_dmrs += group_dmrs_per_uci[lane*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant];
               }
               temp_t_dmrs = complex_conjmul(temp_t_dmrs, d_s[lane]);
            }
            tile.sync();
            temp_t_dmrs = cg::reduce(tile, temp_t_dmrs, cg::plus<__half2>());
            tempf_t_dmrs.x = __half2float(temp_t_dmrs.x)/static_cast<float>(N_TONES_PER_PRB)/static_cast<float>(group_data->nSym_dmrs);
            tempf_t_dmrs.y = __half2float(temp_t_dmrs.y)/static_cast<float>(N_TONES_PER_PRB)/static_cast<float>(group_data->nSym_dmrs);
            rsrpTemp += tempf_t_dmrs.x*tempf_t_dmrs.x + tempf_t_dmrs.y*tempf_t_dmrs.y;
         }
         rsrp_dB = 10.0f * __log10f(rsrpTemp/static_cast<float>(numRxAnt));

         if (lane < N_TONES_PER_PRB) {
            switch (group_data->nSym) {
               case 4: Wt_table_h1 = (__half2 *)d_Wt1_2_2;   break;
               case 5: Wt_table_h1 = (__half2 *)d_Wt_3_2;   break;
               case 6: Wt_table_h1 = (__half2 *)d_Wt1_3_3;    break;
               case 7: Wt_table_h1 = (__half2 *)d_Wt_4_3;    break;
               case 8: Wt_table_h1 = (__half2 *)d_Wt_4_4;  break;
               case 9: Wt_table_h1 = (__half2 *)d_Wt_5_4;  break;
               case 10: Wt_table_h1 = (__half2 *)d_Wt_5_5; break;
               case 11: Wt_table_h1 = (__half2 *)d_Wt_6_5; break;
               case 12: Wt_table_h1 = (__half2 *)d_Wt_6_6; break;
               case 13: Wt_table_h1 = (__half2 *)d_Wt_7_6; break;
               case 14: Wt_table_h1 = (__half2 *)d_Wt_7_7;  break;
               default: break;
            }  
            
            // To conserve memory, we need to do a double-GEMM here so that we don't have to store the intermediate results. Antenna is stored
            // as the outer loop since it's completely independent.
            for (int ant = 0; ant < numRxAnt; ant++) {
               for (int sym = 0; sym < group_data->nSym_dmrs; sym++) {     
                  __half2 accum = {0.0, 0.0};       
                  for (int i = 0; i < N_TONES_PER_PRB; i++) { // Cols of Wf. Each lane processes a single row
                     accum = __hadd2(accum, complex_mul(group_dmrs_per_uci[i*numRxAnt*group_data->nSym_dmrs + sym*numRxAnt + ant],d_Wf[lane][i]));
                  }

                  // Now we have the accumulated value from one cell in C = A*B. Now use that value to sweep over E = C*D. We also apply the element-wise
                  // multiply by conj(s) here as well to avoid more loops
                  for (int E_col = 0; E_col < group_data->nSym_data; E_col++) {
                     group_h_est_iue[lane*numRxAnt*group_data->nSym_data + E_col*numRxAnt + ant] = __hadd2(
                        group_h_est_iue[lane*numRxAnt*group_data->nSym_data + E_col*numRxAnt + ant],
                        complex_conjmul(complex_mul(accum, Wt_table_h1[sym*group_data->nSym_data + E_col]), d_s[lane]));                
                  }
               }
            }
         }

         tile.sync();     

         if (lane < N_TONES_PER_PRB) {
            for (int sym = 0; sym < group_data->nSym_data; sym++) {
               for (int ant = 0; ant < numRxAnt; ant++) {
                  __half2 tmp = complex_conjmul(group_data_per_uci[lane*numRxAnt*group_data->nSym_data + sym*numRxAnt + ant],
                                    group_h_est_iue[lane*numRxAnt*group_data->nSym_data + sym*numRxAnt + ant]);
                       
                  group_h_est_iue[lane*numRxAnt*group_data->nSym_data + sym*numRxAnt + ant] = tmp;
                  qam_est_x += __half2float(tmp.x);
                  qam_est_y += __half2float(tmp.y);
               }
            }
         }         
      }

      tile.sync(); 

      qam_est_x = cg::reduce(tile, qam_est_x, cg::plus<float>());
      qam_est_y = cg::reduce(tile, qam_est_y, cg::plus<float>());     

      // Write the output results from a single thread
      if (lane == 0) {
         // RSSI report
         pDynDescr->pF1UcisOut[uciIdx].RSSI = rssi_dB;

         // RSRP report
         pDynDescr->pF1UcisOut[uciIdx].RSRP = rsrp_dB;
         
         // Bit estimation
         int sr = 0;  
         uint32_t b_est = 0;

         // Determine SR/HARQ confidence levels
         // According to SCF FAPI, Table 3-68, 0 stands for "Good" and 1 stands for "Bad"
         uint8_t SRconfidenceLevel = 0;
         uint8_t HarqconfidenceLevel = 0;

         float abs2_qam = qam_est_x*qam_est_x + qam_est_y*qam_est_y;

         float gapPercDtx = (abs2_qam - dtx_thresh)/abs2_qam;
   
         if (gapPercDtx < confidenceThrF1) {
            SRconfidenceLevel = 1;
            HarqconfidenceLevel = 1;
         }
        
         // Nothing detected. <= is used here because with fp16 is very easy for the estimate and/or the threshold to
         // go to 0 with low SNR scenarios
         #ifdef ENABLE_DEBUG_F1
            if (0){
            printf("uci_idx=%d, abs2_qam=%f, dtx_thresh=%f, rssi_linear=%f, rssi_linear_pow=%f, DTX_in=%f, exp_inv=%f, alpha=%f\n", group_data->uciOutputIdx[0], abs2_qam, dtx_thresh, rssi_linear, __powf(rssi_linear, 1.88), __half2float(group_data->DTXthreshold[0]),d_DtxThrExp_inv[group_data->nUciInGrp-1],alpha);
            }
         #endif
         if (abs2_qam <= dtx_thresh) {
            if (group_data->bitLenHarq[uci] > 0) {
               pDynDescr->pF1UcisOut[uciIdx].HarqValues[0] = 2;
               pDynDescr->pF1UcisOut[uciIdx].HarqValues[1] = 2;
            }
            taEstMicroSec = 0.0;
         } else {
            switch (group_data->bitLenHarq[uci]) {
               case 0: {
                  if (qam_est_x > 0) {
                     sr = 1;
                  }
                  break;
               }
               case 1: {
                  // This is the same as qam_est*(1-j) since the MATLAB code discards the imaginary part
                  b_est = (qam_est_x + qam_est_y <= 0) ? 1 : 0;
                  break;
               }
               case 2: {
                  if (qam_est_x <= 0) {
                     b_est = 1;
                  }
                  if (qam_est_y <= 0) {
                     b_est |= 0b10;
                  }

                  break;
               }
               default:
                  break;
            }

            pDynDescr->pF1UcisOut[uciIdx].HarqValues[0] = b_est & 1;
            pDynDescr->pF1UcisOut[uciIdx].HarqValues[1] = (b_est & 0x2) >> 1;            
         }   

         pDynDescr->pF1UcisOut[uciIdx].SinrDB               = sinr_dB;
         pDynDescr->pF1UcisOut[uciIdx].InterfDB             = interf_dB;
         pDynDescr->pF1UcisOut[uciIdx].NumHarq              = group_data->bitLenHarq[uci];
         pDynDescr->pF1UcisOut[uciIdx].SRindication         = sr;
         pDynDescr->pF1UcisOut[uciIdx].SRconfidenceLevel    = SRconfidenceLevel;
         pDynDescr->pF1UcisOut[uciIdx].HarqconfidenceLevel  = HarqconfidenceLevel;
         pDynDescr->pF1UcisOut[uciIdx].taEstMicroSec        = taEstMicroSec;
      }
   }
 }

 } // namespace pucch_F1

 using namespace pucch_F1;

/**
 * Loads the rBase and csPhaseRamp tables into constant memory
 */
void pucchF1Rx::InitConstantMem(cudaStream_t strm)
{
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_rBase, rBase, sizeof(rBase), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_csPhaseRamp, csPhaseRamp, sizeof(csPhaseRamp), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_s, s, sizeof(s), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_tOCC_1, tOCC_1, sizeof(tOCC_1), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_tOCC_2, tOCC_2, sizeof(tOCC_2), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_tOCC_3, tOCC_3, sizeof(tOCC_3), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_tOCC_4, tOCC_4, sizeof(tOCC_4), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_tOCC_5, tOCC_5, sizeof(tOCC_5), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_tOCC_6, tOCC_6, sizeof(tOCC_6), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_tOCC_7, tOCC_7, sizeof(tOCC_7), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wf, Wf, sizeof(Wf), 0, cudaMemcpyHostToDevice, strm));
 
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_1_1, Wt_1_1, sizeof(Wt_1_1), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt1_2_2, Wt1_2_2, sizeof(Wt1_2_2), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_1_2, Wt_1_2, sizeof(Wt_1_2), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_2_1, Wt_2_1, sizeof(Wt_2_1), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt2_2_2, Wt2_2_2, sizeof(Wt2_2_2), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_2_3, Wt_2_3, sizeof(Wt_2_3), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_3_2, Wt_3_2, sizeof(Wt_3_2), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt1_3_3, Wt1_3_3, sizeof(Wt1_3_3), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt2_3_3, Wt2_3_3, sizeof(Wt2_3_3), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_3_4, Wt_3_4, sizeof(Wt_3_4), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_4_3, Wt_4_3, sizeof(Wt_4_3), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_4_4, Wt_4_4, sizeof(Wt_4_4), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_5_4, Wt_5_4, sizeof(Wt_5_4), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_5_5, Wt_5_5, sizeof(Wt_5_5), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_6_5, Wt_6_5, sizeof(Wt_6_5), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_6_6, Wt_6_6, sizeof(Wt_6_6), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_7_6, Wt_7_6, sizeof(Wt_7_6), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_Wt_7_7, Wt_7_7, sizeof(Wt_7_7), 0, cudaMemcpyHostToDevice, strm));
   CUDA_CHECK(cudaMemcpyToSymbolAsync(d_W_noiseIso, W_noiseIso, sizeof(W_noiseIso), 0, cudaMemcpyHostToDevice, strm));
}

pucchF1Rx::pucchF1Rx(cudaStream_t strm)
{
   {
      std::lock_guard<std::mutex> lockGaurdConstMemInit(m_mutexConstMemInit);
      if(~isConstMemInited)
      {
         isConstMemInited = true;
         InitConstantMem(strm);
      }
   }
}


void  pucchF1Rx::kernelSelect(uint16_t                   nUciGrps,
                              pucchF1RxDynDescr_t*       pCpuDynDesc, 
                              cuphyPucchF1RxLaunchCfg_t* pLaunchCfg)
{
   // kernel (only one kernel option for now)
   void* kernelFunc = reinterpret_cast<void*>(pucchF1RxKernel);
   CUDA_CHECK(cudaGetFuncBySymbol(&pLaunchCfg->kernelNodeParamsDriver.func, kernelFunc));

   // launch geometry (can change!)
   // int max_uci_in_group = 0;
   // for (int grp = 0; grp < nUciGrps; grp++) {
   //    max_uci_in_group = std::max(pCpuDynDesc->uciGrpPrms[grp].nUciInGrp, max_uci_in_group);
   // }

   dim3 gridDim(nUciGrps);
   dim3 blockDim(F1_CG_SIZE, F1_UCIS_PER_GROUP);

   // populate kernel parameters
    CUDA_KERNEL_NODE_PARAMS& kernelNodeParamsDriver = pLaunchCfg->kernelNodeParamsDriver;

    kernelNodeParamsDriver.blockDimX = blockDim.x;
    kernelNodeParamsDriver.blockDimY = blockDim.y;
    kernelNodeParamsDriver.blockDimZ = blockDim.z;
 
    kernelNodeParamsDriver.gridDimX = gridDim.x;
    kernelNodeParamsDriver.gridDimY = gridDim.y;
    kernelNodeParamsDriver.gridDimZ = gridDim.z;
     
    kernelNodeParamsDriver.extra          = nullptr;
    kernelNodeParamsDriver.sharedMemBytes = 0;
}

void pucchF1Rx::setup(cuphyTensorPrm_t*          pDataRx,                     // input slot buffer
                      cuphyPucchF0F1UciOut_t*    pF1UcisOut,                  // pointer to output uci buffer
                      uint16_t                   nCells,                      // number of cells
                      uint16_t                   nF1Ucis,                     // number of F1 Ucis
                      cuphyPucchUciPrm_t*        pF1UciPrms,                  // pointer to uci prm buffer
                      cuphyPucchCellPrm_t*       pCmnCellPrms,                // number of antennas, slot number, hopping idx and input slot buffer
                      bool                       enableCpuToGpuDescrAsyncCpy, // flag, indicates if descriptors copied to gpu at setup
                      pucchF1RxDynDescr_t*       pCpuDynDesc,                 // pointer to descriptor in cpu
                      void*                      pGpuDynDesc,                 // pointer to descriptor in gpu
                      cuphyPucchF1RxLaunchCfg_t* pLaunchCfg,                  // pointer to launch configuration
                      cudaStream_t               strm)                                      // stream to perform copy
{
   // Bin Ucis into groups based on start CRB and symbol:
   uint16_t nUciGrps = 0;
   pCpuDynDesc->pCellPrms = pCmnCellPrms;

   for(int uciIdx = 0; uciIdx < nF1Ucis; ++uciIdx)
   {
      int      newGrpFlag  = 1;
      uint16_t uciStartCrb = pF1UciPrms[uciIdx].startPrb + pF1UciPrms[uciIdx].bwpStart;
      uint8_t  uciStartSym = pF1UciPrms[uciIdx].startSym;
      uint16_t uciCellIdx  = pF1UciPrms[uciIdx].cellPrmDynIdx;
      float extDTXthreshold =  pF1UciPrms[uciIdx].DTXthreshold;

      for(int grpIdx = 0; grpIdx < nUciGrps; grpIdx++)
      {
         uint16_t grpStartCrb = pCpuDynDesc->uciGrpPrms[grpIdx].startCrb;
         uint8_t  grpStartSym = pCpuDynDesc->uciGrpPrms[grpIdx].startSym;
         uint16_t grpCellIdx  = pCpuDynDesc->uciGrpPrms[grpIdx].cellIdx;

         if((uciStartCrb == grpStartCrb) && (uciStartSym == grpStartSym) && (uciCellIdx == grpCellIdx))
         {
            newGrpFlag = 0;
            uint8_t nUciInGrp = pCpuDynDesc->uciGrpPrms[grpIdx].nUciInGrp;
            if(CUPHY_PUCCH_F1_MAX_UCI_PER_GRP <= nUciInGrp)
            {
                NVLOGE_FMT(NVLOG_PUCCH, AERIAL_CUPHY_EVENT, "Number of PF1 UCIs in group {} is more than max allocation ({}).  Dropping additional UCIs.",grpIdx,CUPHY_PUCCH_F1_MAX_UCI_PER_GRP);
                break;
            }

            pCpuDynDesc->uciGrpPrms[grpIdx].nUciInGrp                   = nUciInGrp + 1;
            pCpuDynDesc->uciGrpPrms[grpIdx].bitLenHarq[nUciInGrp]       = pF1UciPrms[uciIdx].bitLenHarq;
            pCpuDynDesc->uciGrpPrms[grpIdx].srFlag[nUciInGrp]           = pF1UciPrms[uciIdx].srFlag;
            pCpuDynDesc->uciGrpPrms[grpIdx].cs0[nUciInGrp]              = pF1UciPrms[uciIdx].initialCyclicShift;
            pCpuDynDesc->uciGrpPrms[grpIdx].uciOutputIdx[nUciInGrp]     = pF1UciPrms[uciIdx].uciOutputIdx;
            if(extDTXthreshold > CUPHY_DEFAULT_EXT_DTX_THRESHOLD)
            {
               pCpuDynDesc->uciGrpPrms[grpIdx].DTXthreshold[nUciInGrp]     = __float2half(extDTXthreshold);
            } else {
               pCpuDynDesc->uciGrpPrms[grpIdx].DTXthreshold[nUciInGrp]     = 1.0;
            }
            pCpuDynDesc->uciGrpPrms[grpIdx].timeDomainOccIdx[nUciInGrp] = pF1UciPrms[uciIdx].timeDomainOccIdx;
            break;
         }
      }

      if(newGrpFlag == 1) 
      {
         if(CUPHY_PUCCH_F1_MAX_GRPS <= nUciGrps)
         {
            NVLOGE_FMT(NVLOG_PUCCH, AERIAL_CUPHY_EVENT, "Number of PF1 UCI groups is more than max allocation ({}).  Dropping additional groups.",CUPHY_PUCCH_F1_MAX_GRPS);
            continue;
         }
         // uci group prms:
         pCpuDynDesc->uciGrpPrms[nUciGrps].nUciInGrp    = 1;
         pCpuDynDesc->uciGrpPrms[nUciGrps].freqHopFlag  = pF1UciPrms[uciIdx].freqHopFlag;
         pCpuDynDesc->uciGrpPrms[nUciGrps].startCrb     = uciStartCrb;
         pCpuDynDesc->uciGrpPrms[nUciGrps].startSym     = pF1UciPrms[uciIdx].startSym;
         pCpuDynDesc->uciGrpPrms[nUciGrps].nSym         = pF1UciPrms[uciIdx].nSym;
         pCpuDynDesc->uciGrpPrms[nUciGrps].groupHopFlag = pF1UciPrms[uciIdx].groupHopFlag;
         pCpuDynDesc->uciGrpPrms[nUciGrps].secondHopCrb = pF1UciPrms[uciIdx].secondHopPrb + pF1UciPrms[uciIdx].bwpStart;

         pCpuDynDesc->uciGrpPrms[nUciGrps].nSym_data    = floor(pCpuDynDesc->uciGrpPrms[nUciGrps].nSym / 2.0);
         pCpuDynDesc->uciGrpPrms[nUciGrps].nSym_dmrs    = pCpuDynDesc->uciGrpPrms[nUciGrps].nSym - pCpuDynDesc->uciGrpPrms[nUciGrps].nSym_data;

         if(pCpuDynDesc->uciGrpPrms[nUciGrps].freqHopFlag == 1)
         {
            pCpuDynDesc->uciGrpPrms[nUciGrps].nSymDataFirstHop    = floor(pCpuDynDesc->uciGrpPrms[nUciGrps].nSym_data / 2.0);
            pCpuDynDesc->uciGrpPrms[nUciGrps].nSymFirstHop        = pCpuDynDesc->uciGrpPrms[nUciGrps].nSym_data;
            pCpuDynDesc->uciGrpPrms[nUciGrps].nSymDMRSFirstHop    = pCpuDynDesc->uciGrpPrms[nUciGrps].nSymFirstHop - pCpuDynDesc->uciGrpPrms[nUciGrps].nSymDataFirstHop;
            pCpuDynDesc->uciGrpPrms[nUciGrps].nSymDataSecondHop   = pCpuDynDesc->uciGrpPrms[nUciGrps].nSym_data - pCpuDynDesc->uciGrpPrms[nUciGrps].nSymDataFirstHop;
            pCpuDynDesc->uciGrpPrms[nUciGrps].nSymDMRSSecondHop   = pCpuDynDesc->uciGrpPrms[nUciGrps].nSym_dmrs - pCpuDynDesc->uciGrpPrms[nUciGrps].nSymDMRSFirstHop;
         }

         // cell index
         pCpuDynDesc->uciGrpPrms[nUciGrps].cellIdx = uciCellIdx;

         // uci specfic prms:
         pCpuDynDesc->uciGrpPrms[nUciGrps].bitLenHarq[0]       = pF1UciPrms[uciIdx].bitLenHarq;
         pCpuDynDesc->uciGrpPrms[nUciGrps].cs0[0]              = pF1UciPrms[uciIdx].initialCyclicShift;
         pCpuDynDesc->uciGrpPrms[nUciGrps].uciOutputIdx[0]     = pF1UciPrms[uciIdx].uciOutputIdx;
         pCpuDynDesc->uciGrpPrms[nUciGrps].srFlag[0]           = pF1UciPrms[uciIdx].srFlag;
         
         
         if(extDTXthreshold > CUPHY_DEFAULT_EXT_DTX_THRESHOLD)
         {
            pCpuDynDesc->uciGrpPrms[nUciGrps].DTXthreshold[0] = __float2half(extDTXthreshold);
         } else {
            pCpuDynDesc->uciGrpPrms[nUciGrps].DTXthreshold[0] = 1.0;
         }
         
         pCpuDynDesc->uciGrpPrms[nUciGrps].timeDomainOccIdx[0] = pF1UciPrms[uciIdx].timeDomainOccIdx;
         // update number of uci groups:
         nUciGrps += 1;
      }
   }

   pCpuDynDesc->numUciGrps = nUciGrps;

   // parameters common to all uci groups:
   for (uint16_t i = 0; i < nCells; i++)
   {
       copyTensorPrm2Info(pDataRx[i], pCpuDynDesc->pCellPrms[i].tDataRx);
   }
   pCpuDynDesc->pF1UcisOut = pF1UcisOut;

   pucchF1KernelArgs_t& kernelArgs = m_kernelArgs;
   kernelArgs.pDynDescr = reinterpret_cast<pucchF1RxDynDescr_t*>(pGpuDynDesc);   

   // Optional descriptor copy to GPU memory
   if(enableCpuToGpuDescrAsyncCpy)
   {
      cudaMemcpyAsync(pGpuDynDesc, pCpuDynDesc, sizeof(pucchF1RxDynDescr_t), cudaMemcpyHostToDevice, strm);
   }

   // select kernel (includes launch geometry). Populate launchCfg.
   kernelSelect(nUciGrps, pCpuDynDesc, pLaunchCfg);
   pLaunchCfg->kernelArgs[0] = &m_kernelArgs.pDynDescr;
   pLaunchCfg->kernelNodeParamsDriver.kernelParams   = &(pLaunchCfg->kernelArgs[0]);

}

 void pucchF1Rx::getDescrInfo(size_t& dynDescrSizeBytes, size_t& dynDescrAlignBytes)
 {
    dynDescrSizeBytes  = sizeof(pucchF1RxDynDescr_t);
    dynDescrAlignBytes = alignof(pucchF1RxDynDescr_t);
 }
